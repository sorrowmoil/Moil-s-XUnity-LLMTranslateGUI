/**
 * MainWindow.cpp - Moil's XUnity LLM Translator GUI Implementation
 * MainWindow.cpp - Moilçš„XUnityå¤§æ¨¡å‹ç¿»è¯‘å™¨GUIå®ç°
 * Updated by CAN: Merged detailed tooltips with full functionality.
 * ç”±CANæ›´æ–°ï¼šåˆå¹¶è¯¦ç»†å·¥å…·æç¤ºä¸å®Œæ•´åŠŸèƒ½
 */

#include "MainWindow.h"
#include "json.hpp"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QGroupBox>
#include <QFileDialog>
#include <QMessageBox>
#include <QApplication>
#include <QFile>
#include <QTextStream>
#include <QCloseEvent>
#include <QStyleFactory>
#include <QPixmap>
#include <QMenu>
#include <QScrollBar>
#include <QGraphicsOpacityEffect>
#include <QPropertyAnimation>
#include <QListView> 
#include <QDesktopServices>
#include <QUrl>
#include <QFileInfo>

// ==========================================
// ğŸŒ å¤šè¯­è¨€å­—å…¸å®šä¹‰ (UI Text)
// ğŸŒ Multi-language Dictionary Definition (UI Text)
// Index 0: English, Index 1: Chinese
// ç´¢å¼•0: è‹±æ–‡, ç´¢å¼•1: ä¸­æ–‡
// ==========================================

// çª—å£æ ‡é¢˜ / Window titles
const char* STR_TITLE[] = {"Moil's XUnity LLM Translator", "Moilçš„XUnityå¤§æ¨¡å‹ç¿»è¯‘GUI"};

// é…ç½®åŒºåŸŸæ ‡é¢˜ / Configuration section titles
const char* STR_API_CFG[] = {"API Configuration", "API é…ç½®"};
const char* STR_LOG_AREA[] = {"Runtime Logs", "è¿è¡Œæ—¥å¿—"};

// APIé…ç½®ç›¸å…³æ–‡æœ¬ / API configuration related text
const char* STR_API_ADDR[] = {"API Address:", "API åœ°å€:"};
const char* STR_API_KEY[] = {"API Key:", "API å¯†é’¥:"};
const char* STR_MODEL[] = {"Model Name:", "æ¨¡å‹åç§°:"};
const char* STR_FETCH[] = {"Fetch", "è·å–"};

// æœåŠ¡å™¨å‚æ•°æ–‡æœ¬ / Server parameter text
const char* STR_PORT[] = {"Port:", "ç«¯å£:"};
const char* STR_THREAD[] = {"Threads:", "çº¿ç¨‹:"};
const char* STR_TEMP[] = {"Temp:", "æ¸©åº¦:"};
const char* STR_CTX[] = {"Context:", "ä¸Šä¸‹æ–‡:"};

// æç¤ºè¯ç›¸å…³æ–‡æœ¬ / Prompt related text
const char* STR_SYS_PROMPT[] = {"System Prompt:", "ç³»ç»Ÿæç¤º:"};
const char* STR_PRE_PROMPT[] = {"Pre-Prompt:", "å‰ç½®æ–‡æœ¬:"};

// æ§åˆ¶æŒ‰é’®æ–‡æœ¬ / Control button text
const char* STR_START[] = {"Start Service", "å¯åŠ¨æœåŠ¡"};
const char* STR_STOP[] = {"Stop Service", "åœæ­¢æœåŠ¡"};
const char* STR_HUD[] = {"HUD Mode", "HUD æ¨¡å¼"};
const char* STR_TEST[] = {"Test Config", "æµ‹è¯•é…ç½®"};
const char* STR_LOAD[] = {"Load Config", "è¯»å–é…ç½®"};
const char* STR_SAVE[] = {"Save Config", "ä¿å­˜é…ç½®"};
const char* STR_EXPORT[] = {"Export Log", "å¯¼å‡ºæ—¥å¿—"};

// ä¸»é¢˜å’Œè¯­è¨€æ–‡æœ¬ / Theme and language text
const char* STR_THEME_LIGHT[] = {"Light Mode", "åˆ‡æ¢äº®è‰²"};
const char* STR_THEME_DARK[] = {"Dark Mode", "åˆ‡æ¢æš—è‰²"};
const char* STR_LANG_BTN[] = {"ä¸­æ–‡", "English"}; // æŒ‰é’®æ–‡æœ¬é€šå¸¸æ˜¾ç¤ºç›®æ ‡è¯­è¨€ / Button text usually shows target language

// æœ¯è¯­è¡¨ç›¸å…³æ–‡æœ¬ / Glossary related text
const char* STR_GLOSSARY[] = {"Glossary:", "æœ¯è¯­è¡¨:"};
const char* STR_CHK_GLOSSARY[] = {"Self-Evolve", "å¯ç”¨è‡ªè¿›åŒ–"};
const char* STR_CLEAR_LOG[] = {"Clear Log", "æ¸…ç©ºæ—¥å¿—"};

// Tokenç»Ÿè®¡æ–‡æœ¬ / Token statistics text
const char* STR_TOKENS[] = {"Tokens:", "æ¶ˆè€—:"};
const char* TIP_TOKENS[] = {"Total Usage (Prompt + Completion)", "æœ¬æ¬¡è¿è¡Œæ€»æ¶ˆè€— (è¾“å…¥+è¾“å‡º)"};

// ==========================================
// ğŸ“ å¤šè¯­è¨€å­—å…¸å®šä¹‰ (Logs)
// ğŸ“ Multi-language Dictionary Definition (Logs)
// Index 0: English, Index 1: Chinese
// ç´¢å¼•0: è‹±æ–‡, ç´¢å¼•1: ä¸­æ–‡
// ==========================================

// æ—¥å¿—æ¶ˆæ¯ / Log messages
const char* LOG_TEST_START[] = {"=== Testing API Keys ===", "=== å¼€å§‹æµ‹è¯•æ‰€æœ‰ API Key ==="};
const char* LOG_NO_KEY[] = {"âŒ No API Key", "âŒ æœªæ‰¾åˆ° API Key"};
const char* LOG_PASS[] = {"Pass", "æµ‹è¯•é€šè¿‡"};
const char* LOG_FAIL[] = {"Fail", "å¤±è´¥"};
const char* LOG_FETCH_SUCCESS[] = {"Fetch Models Success", "æ¨¡å‹åˆ—è¡¨è·å–æˆåŠŸ"};
const char* LOG_FETCH_FAIL[] = {"Fetch Failed: ", "è·å–å¤±è´¥: "};
const char* LOG_PARSE_ERR[] = {"Parse Error", "è§£æé”™è¯¯"};
const char* LOG_CFG_SAVED[] = {"Config Saved: ", "é…ç½®å·²ä¿å­˜: "};
const char* LOG_CFG_LOADED[] = {"Config Loaded: ", "é…ç½®å·²åŠ è½½: "};
const char* LOG_EXPORTED[] = {"Log Exported to run_log.txt", "æ—¥å¿—å·²å¯¼å‡ºåˆ° run_log.txt"};

// ä¸Šä¸‹æ–‡æ¸…ç†ç›¸å…³æ–‡æœ¬ / Context clearing related text
const char* STR_CLEAR_CTX[] = {"Clear", "æ¸…ç©º"};
const char* TIP_CLEAR_CTX[] = {"Clear Context", "æ¸…é™¤å†å²å¯¹è¯è®°å¿†"};

// ğŸ“ æ–°å¢æŒ‰é’®æ–‡æœ¬ / New button text
const char* STR_BTN_AUTO[] = {"Edit", "ç¼–è¾‘"};
const char* TIP_BTN_AUTO[] = {
    "Open _AutoGeneratedTranslations.txt in same folder", 
    "æ‰“å¼€åŒç›®å½•ä¸‹çš„ _AutoGeneratedTranslations.txt (è‡ªåŠ¨ç¿»è¯‘ç»“æœ)"
};

// ==========================================
// ğŸ’¡ è¯¦ç»†å·¥å…·æç¤º (Detailed Tooltips) - Merged
// ğŸ’¡ Detailed Tooltips (Detailed Tooltips) - Merged
// Index 0: English, Index 1: Chinese
// ç´¢å¼•0: è‹±æ–‡, ç´¢å¼•1: ä¸­æ–‡
// ==========================================

// ç«¯å£æç¤º / Port tooltip
const char* TIP_PORT[] = {
    "Local Listening Port\nEnsure XUnity Endpoint is set to http://localhost:port",
    "æœ¬åœ°ç›‘å¬ç«¯å£\nè¯·ç¡®ä¿ XUnity é…ç½®æ–‡ä»¶ Endpoint è®¾ç½®ä¸º http://localhost:ç«¯å£å·"
};

// çº¿ç¨‹æç¤º / Thread tooltip
const char* TIP_THREAD[] = {
    "Concurrent Threads\nRecommended: Depends on your CPU\nNote: Can speed up translation to some extent, too many may cause system lag",
    "å¹¶å‘çº¿ç¨‹æ•° (Max Threads)\nå»ºè®®å€¼: å–å†³äºä½ ç”µè„‘çš„çº¿ç¨‹æ•°\næ³¨æ„: ä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥åŠ å¿«ç¿»è¯‘å·¥ä½œï¼Œè¿‡å¤šä¼šå¯¼è‡´ç³»ç»Ÿå¡é¡¿"
};

// æ¸©åº¦æç¤º / Temperature tooltip
const char* TIP_TEMP[] = {
    "Sampling Temperature\n0.0-0.3: Strict\n0.7-1.0: Standard\n>1.0: Creative/Random",
    "é‡‡æ ·æ¸©åº¦ (Temperature)\n0.0-0.3: ä¸¥è°¨\n0.7-1.0: æ ‡å‡†\n>1.0: éšæœº/åˆ›é€ æ€§"
};

// ä¸Šä¸‹æ–‡æç¤º / Context tooltip
const char* TIP_CTX[] = {
    "Context Memory\nNumber of history turns to carry.\nNote: More context consumes more tokens.",
    "ä¸Šä¸‹æ–‡è®°å¿† (Context)\næºå¸¦çš„å†å²å¯¹è¯è½®æ•°ã€‚\næ³¨æ„ï¼šä¸Šä¸‹æ–‡è¶Šå¤šï¼Œæ¶ˆè€— Token è¶Šå¤šã€‚"
};

// æœ¯è¯­è¡¨æç¤º / Glossary tooltip
const char* TIP_GLOSSARY[] = {
    "Select XUnity's _Substitutions.txt.\nLLM will reference and append to it.",
    "é€‰æ‹© XUnity çš„ _Substitutions.txt æ–‡ä»¶ã€‚\nLLM å°†è‡ªåŠ¨å‚è€ƒå¹¶è¡¥å……è¯¥æ–‡ä»¶ã€‚"
};

// APIä¸‹æ‹‰æ¡†æç¤º / API combobox tip
const char* TIP_COMBO_MAIN[] = {
    "Enter API Address or select from list.\nMust support /v1/chat/completions format.",
    "åœ¨æ­¤è¾“å…¥ API åœ°å€ï¼Œæˆ–ä»ä¸‹æ‹‰åˆ—è¡¨ä¸­é€‰æ‹©ä¸»æµæœåŠ¡å•†ã€‚\næ‰€æœ‰åœ°å€å¿…é¡»å…¼å®¹ OpenAI æ¥å£æ ¼å¼ (/v1/chat/completions)ã€‚"
};

// ==========================================
// âš™ï¸ API Presets
// âš™ï¸ APIé¢„è®¾
// ==========================================

// APIé¢„è®¾æ•°æ®ç»“æ„ / API preset data structure
struct ApiPresetDef {
    const char* url;          // APIåœ°å€ / API URL
    const char* tips[2];      // æç¤ºä¿¡æ¯æ•°ç»„ [0:è‹±æ–‡, 1:ä¸­æ–‡] / Tip array [0:English, 1:Chinese]
};

// APIé¢„è®¾æ•°æ® / API preset data
const ApiPresetDef PRESETS_DATA[] = {
    {"https://api.openai.com/v1", {"OpenAI Official API", "OpenAI å®˜æ–¹æ¥å£"}},
    {"https://api.deepseek.com", {"DeepSeek Official API", "DeepSeek å®˜æ–¹æ¥å£"}},
    {"https://api.x.ai/v1", {"Grok (xAI) Official API", "Grok (xAI) å®˜æ–¹æ¥å£"}},
    {"https://api.siliconflow.cn/v1", {"SiliconFlow", "ç¡…åŸºæµåŠ¨ (SiliconFlow)"}},
    {"https://openrouter.ai/api/v1", {"OpenRouter Aggregator", "OpenRouter èšåˆå¹³å°"}},
    {"https://generativelanguage.googleapis.com/v1beta/openai", {"Google Gemini", "Google Gemini (OpenAI å…¼å®¹ç«¯ç‚¹)"}},
    {"http://localhost:11434/v1", {"Ollama Local Service", "Ollama æœ¬åœ°æœåŠ¡"}},
    {"http://localhost:1234/v1", {"LM Studio Local Service", "LM Studio æœ¬åœ°æœåŠ¡"}}
};

// ==========================================
// ğŸš€ Implementation
// ğŸš€ å®ç°
// ==========================================

/**
 * MainWindowç±»æ„é€ å‡½æ•°
 * MainWindow class constructor
 * @param parent çˆ¶çª—å£æŒ‡é’ˆ / Parent widget pointer
 */
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) {
    // åˆå§‹åŒ–æˆå‘˜å˜é‡ / Initialize member variables
    m_isClosing = false;
    m_isDarkTheme = true;
    m_currentLang = 1; // é»˜è®¤ä¸­æ–‡ / Default to Chinese

    // è®¾ç½®çª—å£å¤§å° / Set window size
    resize(400, 800);

    // åˆ›å»ºTokenç®¡ç†å™¨å’Œç¿»è¯‘æœåŠ¡å™¨ / Create TokenManager and TranslationServer
    m_tokenManager = new TokenManager(this);
    server = new TranslationServer(this);
    
    // åˆ›å»ºHUDçª—å£ / Create HUD window
    m_hudWindow = new HudWindow(nullptr);
    
    // è®¾ç½®UI / Setup UI
    setupUi();

    // è¿æ¥ä¿¡å·å’Œæ§½ / Connect signals and slots
    connect(server, &TranslationServer::logMessage, this, &MainWindow::onLogMessage);
    connect(server, &TranslationServer::tokenUsageReceived, m_tokenManager, &TokenManager::addUsage);
    connect(m_tokenManager, &TokenManager::tokensUpdated, this, &MainWindow::updateTokenDisplay);

    // HUDçª—å£ç›¸å…³è¿æ¥ / HUD window related connections
    connect(m_hudWindow, &HudWindow::requestRestore, this, &MainWindow::restoreFromHud);
    connect(m_tokenManager, &TokenManager::tokensUpdated,  [this](long long t, long long, long long){
        if(m_hudWindow) m_hudWindow->updateTokens(t);
    });
    
    // æœåŠ¡å™¨å·¥ä½œçŠ¶æ€è¿æ¥ / Server work status connections
    connect(server, &TranslationServer::workStarted, this, &MainWindow::onServerWorkStarted);
    connect(server, &TranslationServer::workFinished, this, &MainWindow::onServerWorkFinished);

    // åŠ è½½é…ç½®å¹¶æ›´æ–°UIæ–‡æœ¬ / Load config and update UI text
    loadConfigToUi();
    updateUIText();
    
    // åº”ç”¨æš—è‰²ä¸»é¢˜ / Apply dark theme
    applyTheme(true); 

    // è®¾ç½®çª—å£æ·¡å…¥åŠ¨ç”» / Set window fade-in animation
    setWindowOpacity(0.0);
    fadeAnim = new QPropertyAnimation(this, "windowOpacity");
    fadeAnim->setDuration(500);
    fadeAnim->setStartValue(0.0);
    fadeAnim->setEndValue(1.0);
    fadeAnim->start();
}

/**
 * MainWindowç±»ææ„å‡½æ•°
 * MainWindow class destructor
 */
MainWindow::~MainWindow() {
    // å…³é—­å¹¶åˆ é™¤HUDçª—å£ / Close and delete HUD window
    if (m_hudWindow) {
        m_hudWindow->close();
        delete m_hudWindow;
    }
    
    // åœæ­¢æœåŠ¡å™¨ / Stop server
    server->stopServer();
}

/**
 * çª—å£å…³é—­äº‹ä»¶å¤„ç†
 * Window close event handler
 * @param event å…³é—­äº‹ä»¶å¯¹è±¡ / Close event object
 */
void MainWindow::closeEvent(QCloseEvent *event) {
    // å¦‚æœæ­£åœ¨å…³é—­ä¸­ï¼Œç›´æ¥æ¥å—äº‹ä»¶ / If already closing, accept event directly
    if (m_isClosing) {
        event->accept();
        return;
    }
    
    // ä¿å­˜é…ç½®åˆ°æ–‡ä»¶ / Save config to file
    ConfigManager::saveConfig(getUiConfig(), "config.ini");
    
    // å¦‚æœHUDçª—å£å¯è§ï¼Œå…³é—­å®ƒ / If HUD window is visible, close it
    if (m_hudWindow->isVisible()) {
        m_hudWindow->close();
    }
    
    // å¿½ç•¥äº‹ä»¶ï¼Œå¼€å§‹æ·¡å‡ºåŠ¨ç”» / Ignore event, start fade out animation
    event->ignore();
    m_isClosing = true;
    fadeOutAndClose();
}

/**
 * æ·¡å‡ºå¹¶å…³é—­çª—å£
 * Fade out and close window
 */
void MainWindow::fadeOutAndClose() {
    // è®¾ç½®åŠ¨ç”»åå‘æ’­æ”¾ / Set animation to play backwards
    fadeAnim->setDirection(QAbstractAnimation::Backward);
    
    // åŠ¨ç”»å®Œæˆæ—¶å…³é—­çª—å£å’Œåº”ç”¨ç¨‹åº / Close window and application when animation finishes
    connect(fadeAnim, &QPropertyAnimation::finished, this, &QMainWindow::close);
    connect(fadeAnim, &QPropertyAnimation::finished, qApp, &QApplication::quit);
    
    fadeAnim->start();
}

/**
 * å¹³æ»‘åˆ‡æ¢æ•ˆæœ
 * Smooth switching effect
 * @param changeLogic éœ€è¦æ‰§è¡Œçš„åˆ‡æ¢é€»è¾‘ / Switching logic to execute
 */
void MainWindow::smoothSwitch(std::function<void()> changeLogic) {
    // æ•è·å½“å‰çª—å£æˆªå›¾ / Capture current window screenshot
    QPixmap pixmap = this->grab();
    QLabel* overlay = new QLabel(this);
    overlay->setPixmap(pixmap);
    overlay->setGeometry(0, 0, this->width(), this->height());
    overlay->show();

    // æ‰§è¡Œåˆ‡æ¢é€»è¾‘ / Execute switching logic
    changeLogic();

    // åˆ›å»ºæ·¡å‡ºæ•ˆæœ / Create fade out effect
    QGraphicsOpacityEffect* effect = new QGraphicsOpacityEffect(overlay);
    overlay->setGraphicsEffect(effect);

    // åˆ›å»ºåŠ¨ç”» / Create animation
    QPropertyAnimation* anim = new QPropertyAnimation(effect, "opacity");
    anim->setDuration(300);
    anim->setStartValue(1.0);
    anim->setEndValue(0.0);
    
    // åŠ¨ç”»å®Œæˆæ—¶åˆ é™¤è¦†ç›–å±‚ / Delete overlay when animation finishes
    connect(anim, &QPropertyAnimation::finished, overlay, &QLabel::deleteLater);
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}

/**
 * åˆ‡æ¢è¯­è¨€
 * Toggle language
 */
void MainWindow::toggleLanguage() {
    smoothSwitch([this](){
        // åˆ‡æ¢è¯­è¨€ç´¢å¼• / Toggle language index
        m_currentLang = (m_currentLang == 0) ? 1 : 0;
        
        // æ›´æ–°UIæ–‡æœ¬ / Update UI text
        updateUIText();
        
        // æ›´æ–°ä¸»é¢˜æŒ‰é’®æ–‡æœ¬ / Update theme button text
        if(themeBtn) themeBtn->setText(m_isDarkTheme ? STR_THEME_LIGHT[m_currentLang] : STR_THEME_DARK[m_currentLang]);
        
        // æ›´æ–°æœåŠ¡å™¨é…ç½® / Update server configuration
        server->updateConfig(getUiConfig());
        
        // å¤„ç†äº‹ä»¶å¹¶è°ƒæ•´çª—å£å¤§å° / Process events and adjust window size
        qApp->processEvents();
        adjustSize();
        resize(400, 800); 
    });
}

/**
 * åˆ‡æ¢ä¸»é¢˜
 * Toggle theme
 */
void MainWindow::toggleTheme() {
    smoothSwitch([this](){
        // åº”ç”¨ç›¸åçš„ä¸»é¢˜ / Apply opposite theme
        applyTheme(!m_isDarkTheme);
    });
}

/**
 * æ·»åŠ æœ¯è¯­è¡¨æ–‡ä»¶åˆ°å†å²è®°å½•
 * Add glossary file to history
 * @param path æœ¯è¯­è¡¨æ–‡ä»¶è·¯å¾„ / Glossary file path
 */
void MainWindow::addToGlossaryHistory(const QString& path) {
    if (path.isEmpty()) return;
    
    // è·å–å½“å‰å†å²è®°å½• / Get current history
    QStringList items;
    for (int i = 0; i < glossaryCombo->count(); ++i) {
        items << glossaryCombo->itemText(i);
    }
    
    // ç§»é™¤é‡å¤é¡¹å¹¶æ·»åŠ åˆ°é¦–ä½ / Remove duplicates and add to front
    items.removeAll(path);
    items.insert(0, path);
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡ / Limit history count
    while (items.size() > 5) {
        items.removeLast();
    }
    
    // æ›´æ–°ä¸‹æ‹‰æ¡† / Update combobox
    glossaryCombo->clear();
    glossaryCombo->addItems(items);
    glossaryCombo->setCurrentIndex(0); 
}

/**
 * é€‰æ‹©æœ¯è¯­è¡¨æ–‡ä»¶
 * Select glossary file
 */
void MainWindow::onSelectGlossary() {
    // æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡† / Open file dialog
    QString fileName = QFileDialog::getOpenFileName(this, "Select File", "", "Text Files (*.txt);;All Files (*.*)");
    
    // å¦‚æœé€‰æ‹©äº†æ–‡ä»¶ï¼Œæ·»åŠ åˆ°å†å²è®°å½• / If file selected, add to history
    if (!fileName.isEmpty()) {
        addToGlossaryHistory(fileName);
    }
}

/**
 * æ‰“å¼€è‡ªåŠ¨ç¿»è¯‘æ–‡ä»¶
 * Open auto-generated translations file
 */
void MainWindow::onOpenAutoTranslations() {
    // è·å–å½“å‰æœ¯è¯­è¡¨è·¯å¾„ / Get current glossary path
    QString currentPath = glossaryCombo->currentText();
    if (currentPath.isEmpty()) {
        return;
    }

    // è·å–ç›®å½•å¹¶æ„å»ºè‡ªåŠ¨ç¿»è¯‘æ–‡ä»¶è·¯å¾„ / Get directory and build auto translation file path
    QFileInfo fi(currentPath);
    QString dir = fi.absolutePath();
    
    // å‡è®¾è‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶ä¸ _Substitutions.txt åœ¨åŒä¸€ç›®å½•
    // Assuming auto-generated file is in same directory as _Substitutions.txt
    QString targetFile = dir + "/_AutoGeneratedTranslations.txt";

    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ / Check if file exists
    QFileInfo targetFi(targetFile);
    if (!targetFi.exists()) {
        QMessageBox::warning(this, 
            (m_currentLang == 1 ? "æ–‡ä»¶æœªæ‰¾åˆ°" : "File Not Found"), 
            (m_currentLang == 1 ? "æœªæ‰¾åˆ° _AutoGeneratedTranslations.txtã€‚\nè¯·ç¡®è®¤æ¸¸æˆæ˜¯å¦å·²ç»è¿è¡Œå¹¶ç”Ÿæˆäº†ç¿»è¯‘ã€‚" : 
            "Could not find _AutoGeneratedTranslations.txt.\nPlease ensure the game has run and generated translations."));
        return;
    }

    // ä½¿ç”¨ç³»ç»Ÿé»˜è®¤ç¼–è¾‘å™¨æ‰“å¼€ / Open with system default editor
    QDesktopServices::openUrl(QUrl::fromLocalFile(targetFile));
}

/**
 * æ›´æ–°UIæ–‡æœ¬ï¼ˆå¤šè¯­è¨€æ”¯æŒï¼‰
 * Update UI text (multi-language support)
 */
void MainWindow::updateUIText() {
    // æ ¹æ®å½“å‰è¯­è¨€è·å–ç´¢å¼• / Get index based on current language
    int i = m_currentLang;
    
    // è®¾ç½®çª—å£æ ‡é¢˜ / Set window title
    setWindowTitle(STR_TITLE[i]);
    
    // è®¾ç½®ç»„æ¡†æ ‡é¢˜ / Set group box titles
    cfgGroup->setTitle(STR_API_CFG[i]);
    logGroup->setTitle(STR_LOG_AREA[i]);

    // è®¾ç½®APIé…ç½®æ ‡ç­¾ / Set API configuration labels
    lblApiAddr->setText(STR_API_ADDR[i]);
    lblApiKey->setText(STR_API_KEY[i]);
    lblModel->setText(STR_MODEL[i]);
    fetchModelBtn->setText(STR_FETCH[i]);

    // è®¾ç½®æœåŠ¡å™¨å‚æ•°æ ‡ç­¾ / Set server parameter labels
    lblPort->setText(STR_PORT[i]);
    lblThread->setText(STR_THREAD[i]);
    lblTemp->setText(STR_TEMP[i]);
    lblCtx->setText(STR_CTX[i]);
    
    // è®¾ç½®æç¤ºè¯æ ‡ç­¾ / Set prompt labels
    lblSysPrompt->setText(STR_SYS_PROMPT[i]);
    lblPrePrompt->setText(STR_PRE_PROMPT[i]);

    // è®¾ç½®ä¸Šä¸‹æ–‡æ¸…ç†æŒ‰é’® / Set context clear button
    clearCtxBtn->setText(STR_CLEAR_CTX[i]);
    clearCtxBtn->setToolTip(TIP_CLEAR_CTX[i]);

    // è®¾ç½®æœ¯è¯­è¡¨ç›¸å…³æ§ä»¶ / Set glossary related controls
    lblGlossary->setText(STR_GLOSSARY[i]);
    chkGlossary->setText(STR_CHK_GLOSSARY[i]);

    // è®¾ç½®æ§åˆ¶æŒ‰é’®æ–‡æœ¬ / Set control button text
    startBtn->setText(STR_START[i]);
    stopBtn->setText(STR_STOP[i]);
    hudBtn->setText(STR_HUD[i]); 
    testBtn->setText(STR_TEST[i]);
    loadBtn->setText(STR_LOAD[i]);
    saveBtn->setText(STR_SAVE[i]);
    exportBtn->setText(STR_EXPORT[i]);
    langBtn->setText(STR_LANG_BTN[i]);

    // è®¾ç½®è‡ªåŠ¨ç¿»è¯‘æŒ‰é’® / Set auto translation button
    if (btnOpenAuto) {
        btnOpenAuto->setText(STR_BTN_AUTO[i]);
        btnOpenAuto->setToolTip(TIP_BTN_AUTO[i]);
    }

    // ğŸŒŸ æ›´æ–°ä¸ºè¯¦ç»†çš„ Tooltips ğŸŒŸ
    // ğŸŒŸ Update to detailed tooltips ğŸŒŸ
    portEdit->setToolTip(TIP_PORT[i]);
    lblPort->setToolTip(TIP_PORT[i]);
    
    threadSpin->setToolTip(TIP_THREAD[i]);
    lblThread->setToolTip(TIP_THREAD[i]);
    
    tempSpin->setToolTip(TIP_TEMP[i]);
    lblTemp->setToolTip(TIP_TEMP[i]);
    
    contextSpin->setToolTip(TIP_CTX[i]);
    lblCtx->setToolTip(TIP_CTX[i]);

    // è®¾ç½®æœ¯è¯­è¡¨å·¥å…·æç¤º / Set glossary tooltips
    lblGlossary->setToolTip(TIP_GLOSSARY[i]);
    chkGlossary->setToolTip(TIP_GLOSSARY[i]);
    btnSelectGlossary->setToolTip(TIP_GLOSSARY[i]);
    
    if (glossaryCombo) {
        glossaryCombo->setToolTip(TIP_GLOSSARY[i]);
    }
    
    // è®¾ç½®HUDæŒ‰é’®å·¥å…·æç¤º / Set HUD button tooltip
    hudBtn->setToolTip(i==0 ? "Switch to Mini-HUD mode" : "åˆ‡æ¢è‡³è¿·ä½ æ‚¬æµ®çª—æ¨¡å¼");
    
    // æ›´æ–°APIä¸‹æ‹‰æ¡†æç¤ºå’Œé€‰é¡¹æç¤º / Update API combobox tooltip and item tooltips
    if (apiAddressCombo) {
        apiAddressCombo->setToolTip(TIP_COMBO_MAIN[i]);
        
        // éå†æ›´æ–°ä¸‹æ‹‰é€‰é¡¹çš„æç¤º / Iterate to update dropdown item tooltips
        for (int k = 0; k < apiAddressCombo->count(); ++k) {
            QString itemUrl = apiAddressCombo->itemText(k);
            
            // åœ¨é¢„è®¾åˆ—è¡¨ä¸­æŸ¥æ‰¾å¯¹åº”çš„URL / Find corresponding URL in preset list
            for (const auto& preset : PRESETS_DATA) {
                if (itemUrl == preset.url) {
                    // è®¾ç½®å¯¹åº”è¯­è¨€çš„æç¤º / Set tooltip in corresponding language
                    apiAddressCombo->setItemData(k, preset.tips[i], Qt::ToolTipRole);
                    break;
                }
            }
        }
    }

    // æ›´æ–°Tokenæ˜¾ç¤º / Update token display
    lblTokens->setText(QString("%1 %2").arg(STR_TOKENS[i]).arg(m_tokenManager->getTotal()));
    lblTokens->setToolTip(TIP_TOKENS[i]);
}

/**
 * åº”ç”¨ä¸»é¢˜æ ·å¼
 * Apply theme styling
 * @param isDark æ˜¯å¦ä¸ºæš—è‰²ä¸»é¢˜ / Whether to apply dark theme
 */
void MainWindow::applyTheme(bool isDark) {
    // æ¢å¤é»˜è®¤æ ·å¼ / Restore default style
    qApp->setStyle(QStyleFactory::create("Fusion"));
    
    // å®šä¹‰é¢œè‰²å˜é‡ / Define color variables
    QColor windowColor, baseColor, textColor, btnColor, highlightColor, linkColor;
    QString qssBtnBorder, qssBtnBg, qssBtnHover;
    
    // ä¸‹æ‹‰æŒ‰é’®ä¸“ç”¨çš„åå·®è‰² / Contrast colors specifically for dropdown buttons
    QString dropDownBg, dropDownHover; 
    
    // è®¾ç½®æ·±è‰²æˆ–äº®è‰²æ¨¡å¼çš„é…è‰²æ–¹æ¡ˆ
    // Set color scheme for dark or light mode
    if (isDark) {
        // === æ·±è‰²æ¨¡å¼é…è‰² / Dark mode color scheme ===
        windowColor = QColor(30, 30, 30);    
        baseColor   = QColor(37, 37, 38);    // è¾“å…¥æ¡†èƒŒæ™¯ / Input field background: Dark gray
        textColor   = QColor(220, 220, 220); 
        btnColor    = QColor(60, 60, 60);    
        highlightColor = QColor(0, 122, 204); 
        linkColor   = QColor(86, 156, 214);
        qssBtnBorder = "#555555";
        qssBtnBg     = "#3C3C3C";
        qssBtnHover  = "#505050";
        
        // åå·®è‰²è®¾è®¡ï¼šèƒŒæ™¯é»‘ -> æŒ‰é’®äº® / Contrast design: Black background -> Light buttons
        dropDownBg    = "#C0C0C0"; 
        dropDownHover = "#FFFFFF"; 
        
        // æ›´æ–°ä¸»é¢˜æŒ‰é’®æ–‡æœ¬ / Update theme button text
        if(themeBtn) themeBtn->setText(STR_THEME_LIGHT[m_currentLang]);
    } else {
        // === äº®è‰²æ¨¡å¼é…è‰² / Light mode color scheme ===
        windowColor = QColor(240, 240, 240);
        baseColor   = QColor(255, 255, 255); // è¾“å…¥æ¡†èƒŒæ™¯ / Input field background: Pure white
        textColor   = QColor(0, 0, 0);
        btnColor    = QColor(225, 225, 225);
        highlightColor = QColor(0, 120, 215);
        linkColor   = QColor(0, 0, 255);
        qssBtnBorder = "#C0C0C0";
        qssBtnBg     = "#E1E1E1";
        qssBtnHover  = "#D0D0D0";
        
        // åå·®è‰²è®¾è®¡ï¼šèƒŒæ™¯ç™½ -> æŒ‰é’®æš— / Contrast design: White background -> Dark buttons
        dropDownBg    = "#4D4D4D"; 
        dropDownHover = "#2D2D2D"; 
        
        // æ›´æ–°ä¸»é¢˜æŒ‰é’®æ–‡æœ¬ / Update theme button text
        if(themeBtn) themeBtn->setText(STR_THEME_DARK[m_currentLang]);
    }
    
    // è®¾ç½®å…¨å±€è°ƒè‰²æ¿ / Set global palette
    QPalette p;
    p.setColor(QPalette::Window, windowColor);
    p.setColor(QPalette::WindowText, textColor);
    p.setColor(QPalette::Base, baseColor); 
    p.setColor(QPalette::AlternateBase, windowColor);
    p.setColor(QPalette::ToolTipBase, baseColor);
    p.setColor(QPalette::ToolTipText, textColor);
    p.setColor(QPalette::Text, textColor);
    p.setColor(QPalette::Button, btnColor);
    p.setColor(QPalette::ButtonText, textColor);
    p.setColor(QPalette::Link, linkColor);
    p.setColor(QPalette::Highlight, highlightColor);
    p.setColor(QPalette::HighlightedText, Qt::white);
    qApp->setPalette(p);
    
    // åº”ç”¨QSSæ ·å¼è¡¨ / Apply QSS stylesheet
    // CAN UPDATED: Changed QToolTip color from %6 (highlightColor) to #E6B422 (Gold)
    QString qss = QString(R"(
        QGroupBox { border: 1px solid %1; border-radius: 5px; margin-top: 1.2em; font-weight: bold; }
        QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; left: 10px; padding: 0 3px; color: %6; }
        QPushButton { border: 1px solid %3; border-radius: 4px; background-color: %4; padding: 5px; font-weight: bold; }
        QPushButton:hover { background-color: %5; border-color: %2; }
        QPushButton:pressed { background-color: %2; color: white; border-color: %2; }
        QPushButton:disabled { background-color: transparent; border: 1px solid %1; color: gray; }
        
        QLineEdit, QComboBox { border: 1px solid %3; border-radius: 4px; background-color: %7; padding: 4px; color: palette(text); selection-background-color: %2; }
        QComboBox:hover, QLineEdit:hover { border-color: %2; }
        
        QComboBox::drop-down { subcontrol-origin: padding; subcontrol-position: top right; width: 25px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; background-color: %9; border-left-width: 1px; border-left-color: %3; border-left-style: solid; }
        QComboBox::drop-down:hover { background-color: %10; }
        QComboBox::down-arrow { image: none; width: 0px; height: 0px; border: none; }
        QComboBox QAbstractItemView { border: 1px solid %2; selection-background-color: %2; background-color: %7; outline: none; }
        
        QPushButton#btnStart { background-color: #388E3C; color: white; border: 1px solid #2E7D32; }
        QPushButton#btnStart:hover { background-color: #4CAF50; border-color: #43A047; }
        QPushButton#btnStart:pressed { background-color: #1B5E20; border-color: #1B5E20; }
        QPushButton#btnStart:disabled { background-color: transparent; border: 1px solid %1; color: gray; }
        QLabel#lblTokens { color: #E6B422; font-weight: bold; }
        
        QToolTip { border: 1px solid %2; background-color: %7; color: #E6B422; opacity: 230; padding: 4px; border-radius: 3px; }
    )")
    .arg(qssBtnBorder).arg(highlightColor.name()).arg(qssBtnBorder).arg(qssBtnBg).arg(qssBtnHover)
    .arg(highlightColor.name()).arg(baseColor.name()).arg(textColor.name()).arg(dropDownBg).arg(dropDownHover);
    
    qApp->setStyleSheet(qss);
    
    // æ›´æ–°ä¸»é¢˜çŠ¶æ€ / Update theme state
    m_isDarkTheme = isDark;
}

/**
 * è®¾ç½®UIç•Œé¢
 * Setup UI interface
 */
void MainWindow::setupUi() {
    // åˆ›å»ºä¸­å¿ƒéƒ¨ä»¶å’Œä¸»å¸ƒå±€ / Create central widget and main layout
    QWidget *central = new QWidget(this);
    setCentralWidget(central);
    QVBoxLayout *mainLayout = new QVBoxLayout(central);
    mainLayout->setSpacing(10);
    mainLayout->setContentsMargins(10, 10, 10, 10);

    // === é…ç½®ç»„æ¡† / Configuration GroupBox ===
    cfgGroup = new QGroupBox(this);
    QGridLayout *grid = new QGridLayout(cfgGroup);
    grid->setColumnStretch(1, 1);
    grid->setVerticalSpacing(8);
    grid->setHorizontalSpacing(10);

    // æ ‡ç­¾åˆ›å»ºè¾…åŠ©å‡½æ•° / Label creation helper function
    auto createLabel = [this](QLabel*& memberPtr) {
        memberPtr = new QLabel(this);
        memberPtr->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
        return memberPtr;
    };

    // APIåœ°å€ä¸‹æ‹‰æ¡† / API address combobox
    apiAddressCombo = new QComboBox(this);
    apiAddressCombo->setEditable(true); 
    apiAddressCombo->setMinimumHeight(28);
    
    // ä»å…¨å±€å­—å…¸åŠ è½½é¢„è®¾ / Load presets from global dictionary
    for(const auto& p : PRESETS_DATA) {
        apiAddressCombo->addItem(p.url);
        // åˆå§‹åŠ è½½æ—¶ï¼Œæ ¹æ®å½“å‰è¯­è¨€è®¾ç½®æç¤º / Set tooltip based on current language during initial load
        apiAddressCombo->setItemData(apiAddressCombo->count()-1, p.tips[m_currentLang], Qt::ToolTipRole);
    }
    apiAddressCombo->setCurrentIndex(0);

    grid->addWidget(createLabel(lblApiAddr), 0, 0);
    grid->addWidget(apiAddressCombo, 0, 1);

    // APIå¯†é’¥è¾“å…¥æ¡† / API key input field
    apiKeyEdit = new QLineEdit(this);
    apiKeyEdit->setEchoMode(QLineEdit::Normal); 
    grid->addWidget(createLabel(lblApiKey), 1, 0);
    grid->addWidget(apiKeyEdit, 1, 1);

    // æ¨¡å‹è·å–è¡Œ / Model fetch row
    QWidget *modelContainer = new QWidget(this);
    QHBoxLayout *modelLayout = new QHBoxLayout(modelContainer);
    modelLayout->setContentsMargins(0, 0, 0, 0);
    modelLayout->setSpacing(5);
    
    modelCombo = new QComboBox(this);
    modelCombo->setEditable(true);
    modelCombo->setMinimumHeight(28); 
    
    fetchModelBtn = new QPushButton(this);
    connect(fetchModelBtn, &QPushButton::clicked, this, &MainWindow::onFetchModels);
    
    modelLayout->addWidget(modelCombo, 1); 
    modelLayout->addWidget(fetchModelBtn);
    grid->addWidget(createLabel(lblModel), 2, 0);
    grid->addWidget(modelContainer, 2, 1);

    // å‚æ•°è¡Œ / Parameters row
    QWidget *paramContainer = new QWidget(this);
    QHBoxLayout *paramLayout = new QHBoxLayout(paramContainer);
    paramLayout->setContentsMargins(0, 0, 0, 0);
    paramLayout->setSpacing(8); 

    // åˆ›å»ºå‚æ•°æ§ä»¶ / Create parameter controls
    lblPort = new QLabel(this);
    portEdit = new QLineEdit(this);
    portEdit->setFixedWidth(55);
    portEdit->setAlignment(Qt::AlignCenter);

    lblThread = new QLabel(this);
    threadSpin = new QSpinBox(this);
    threadSpin->setRange(1, 200);
    threadSpin->setFixedWidth(55);
    threadSpin->setAlignment(Qt::AlignCenter);

    lblTemp = new QLabel(this);
    tempSpin = new QDoubleSpinBox(this);
    tempSpin->setRange(0, 2);
    tempSpin->setSingleStep(0.1);
    tempSpin->setFixedWidth(55);
    tempSpin->setAlignment(Qt::AlignCenter);

    lblCtx = new QLabel(this);
    contextSpin = new QSpinBox(this);
    contextSpin->setRange(0, 20);
    contextSpin->setFixedWidth(55);
    contextSpin->setAlignment(Qt::AlignCenter);

    clearCtxBtn = new QPushButton(this);
    clearCtxBtn->setFixedWidth(50);
    connect(clearCtxBtn, &QPushButton::clicked, this, &MainWindow::onClearContext);

    lblTokens = new QLabel(this);
    lblTokens->setObjectName("lblTokens"); 

    // æ·»åŠ å‚æ•°æ§ä»¶åˆ°å¸ƒå±€ / Add parameter controls to layout
    paramLayout->addWidget(lblPort);
    paramLayout->addWidget(portEdit);
    paramLayout->addWidget(lblThread);
    paramLayout->addWidget(threadSpin);
    paramLayout->addWidget(lblTemp);
    paramLayout->addWidget(tempSpin);
    paramLayout->addWidget(lblCtx);
    paramLayout->addWidget(contextSpin);
    paramLayout->addWidget(clearCtxBtn);
    paramLayout->addWidget(lblTokens);
    paramLayout->addStretch();

    grid->addWidget(paramContainer, 3, 0, 1, 2);

    // ç³»ç»Ÿæç¤ºè¯è¾“å…¥æ¡† / System prompt input field
    systemPromptEdit = new QTextEdit(this);
    systemPromptEdit->setMinimumHeight(100); 
    lblSysPrompt = new QLabel(this);
    lblSysPrompt->setAlignment(Qt::AlignRight | Qt::AlignTop);
    grid->addWidget(lblSysPrompt, 4, 0);
    grid->addWidget(systemPromptEdit, 4, 1);

    // å‰ç½®æ–‡æœ¬è¾“å…¥æ¡† / Pre-prompt input field
    prePromptEdit = new QLineEdit(this);
    grid->addWidget(createLabel(lblPrePrompt), 5, 0);
    grid->addWidget(prePromptEdit, 5, 1);

    // æœ¯è¯­è¡¨é€‰æ‹©åŒºåŸŸ / Glossary selection area
    QWidget *glossaryContainer = new QWidget(this);
    QHBoxLayout *glossaryLayout = new QHBoxLayout(glossaryContainer);
    glossaryLayout->setContentsMargins(0, 0, 0, 0);
    
    chkGlossary = new QCheckBox(this);
    
    glossaryCombo = new QComboBox(this);
    glossaryCombo->setEditable(true); 
    glossaryCombo->setMinimumHeight(28);
    glossaryCombo->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Fixed); 
    
    btnOpenAuto = new QPushButton(STR_BTN_AUTO[m_currentLang], this);
    btnOpenAuto->setFixedWidth(50);
    connect(btnOpenAuto, &QPushButton::clicked, this, &MainWindow::onOpenAutoTranslations);

    btnSelectGlossary = new QPushButton("...", this);
    btnSelectGlossary->setFixedWidth(35);
    connect(btnSelectGlossary, &QPushButton::clicked, this, &MainWindow::onSelectGlossary);

    glossaryLayout->addWidget(chkGlossary);
    glossaryLayout->addWidget(glossaryCombo, 1); 
    glossaryLayout->addWidget(btnOpenAuto);
    glossaryLayout->addWidget(btnSelectGlossary);
    
    grid->addWidget(createLabel(lblGlossary), 6, 0);
    grid->addWidget(glossaryContainer, 6, 1);

    // æ·»åŠ é…ç½®ç»„æ¡†åˆ°ä¸»å¸ƒå±€ / Add configuration group box to main layout
    mainLayout->addWidget(cfgGroup);

    // === æŒ‰é’®ç½‘æ ¼å¸ƒå±€ / Buttons Grid Layout ===
    QGridLayout *btnGridLayout = new QGridLayout();
    btnGridLayout->setSpacing(10);
    
    // æŒ‰é’®åˆ›å»ºè¾…åŠ©å‡½æ•° / Button creation helper function
    auto createBtn = [this] (QPushButton*& btnPtr) {
        btnPtr = new QPushButton(this);
        btnPtr->setMinimumHeight(32);
        btnPtr->setCursor(Qt::PointingHandCursor);
        return btnPtr;
    };

    // ç¬¬0è¡Œï¼šå¯åŠ¨ | åœæ­¢ | HUD / Row 0: Start | Stop | HUD
    btnGridLayout->addWidget(createBtn(startBtn), 0, 0);
    startBtn->setObjectName("btnStart"); 

    btnGridLayout->addWidget(createBtn(stopBtn), 0, 1);
    stopBtn->setEnabled(false);
    
    hudBtn = new QPushButton(this);
    hudBtn->setMinimumHeight(32);
    hudBtn->setCursor(Qt::PointingHandCursor);
    hudBtn->setEnabled(false); 
    connect(hudBtn, &QPushButton::clicked, this, &MainWindow::switchToHud);
    btnGridLayout->addWidget(hudBtn, 0, 2);

    // ç¬¬1è¡Œï¼šæµ‹è¯• | å¯¼å‡º | åŠ è½½ / Row 1: Test | Export | Load
    btnGridLayout->addWidget(createBtn(testBtn), 1, 0);
    btnGridLayout->addWidget(createBtn(exportBtn), 1, 1);
    btnGridLayout->addWidget(createBtn(loadBtn), 1, 2);

    // ç¬¬2è¡Œï¼šä¿å­˜ | ä¸»é¢˜ | è¯­è¨€ / Row 2: Save | Theme | Language
    btnGridLayout->addWidget(createBtn(saveBtn), 2, 0);
    btnGridLayout->addWidget(createBtn(themeBtn), 2, 1);
    btnGridLayout->addWidget(createBtn(langBtn), 2, 2);

    // è¿æ¥æŒ‰é’®ä¿¡å· / Connect button signals
    connect(themeBtn, &QPushButton::clicked, this, &MainWindow::toggleTheme);
    connect(langBtn, &QPushButton::clicked, this, &MainWindow::toggleLanguage);
    connect(startBtn, &QPushButton::clicked, this, &MainWindow::onStartClicked);
    connect(stopBtn, &QPushButton::clicked, this, &MainWindow::onStopClicked);
    connect(testBtn, &QPushButton::clicked, this, &MainWindow::onTestConfig);
    connect(loadBtn, &QPushButton::clicked, this, &MainWindow::onLoadConfig);
    connect(saveBtn, &QPushButton::clicked, this, &MainWindow::onSaveConfig);
    connect(exportBtn, &QPushButton::clicked, this, &MainWindow::onExportLog);

    // æ·»åŠ æŒ‰é’®å¸ƒå±€åˆ°ä¸»å¸ƒå±€ / Add button layout to main layout
    mainLayout->addLayout(btnGridLayout);

    // === æ—¥å¿—åŒºåŸŸ / Log Area ===
    logGroup = new QGroupBox(this);
    QVBoxLayout *logLayout = new QVBoxLayout(logGroup);
    logLayout->setContentsMargins(10, 20, 10, 10);
    logArea = new QTextEdit(this);
    logArea->setReadOnly(true);
    logArea->setMinimumHeight(150); 
    logArea->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(logArea, &QTextEdit::customContextMenuRequested, this, &MainWindow::onLogContextMenu);
    logLayout->addWidget(logArea);
    mainLayout->addWidget(logGroup);
}

/**
 * æ—¥å¿—åŒºåŸŸä¸Šä¸‹æ–‡èœå•
 * Log area context menu
 * @param pos èœå•ä½ç½® / Menu position
 */
void MainWindow::onLogContextMenu(const QPoint &pos) {
    // åˆ›å»ºæ ‡å‡†ä¸Šä¸‹æ–‡èœå• / Create standard context menu
    QMenu *menu = logArea->createStandardContextMenu();
    menu->addSeparator();
    
    // æ·»åŠ æ¸…ç©ºæ—¥å¿—é€‰é¡¹ / Add clear log option
    QAction *clearAction = menu->addAction(STR_CLEAR_LOG[m_currentLang]);
    connect(clearAction, &QAction::triggered, logArea, &QTextEdit::clear);
    
    // æ˜¾ç¤ºèœå• / Show menu
    menu->exec(logArea->mapToGlobal(pos));
    delete menu;
}

/**
 * åŠ è½½é…ç½®åˆ°UI
 * Load configuration to UI
 */
void MainWindow::loadConfigToUi() {
    // ä»é…ç½®æ–‡ä»¶åŠ è½½é…ç½® / Load configuration from config file
    AppConfig cfg = ConfigManager::loadConfig();
    
    // è®¾ç½®å„æ§ä»¶å€¼ / Set values for each control
    apiAddressCombo->setCurrentText(cfg.api_address);
    apiKeyEdit->setText(cfg.api_key);
    modelCombo->setCurrentText(cfg.model_name);
    portEdit->setText(QString::number(cfg.port));
    tempSpin->setValue(cfg.temperature);
    contextSpin->setValue(cfg.context_num);
    threadSpin->setValue(cfg.max_threads);
    systemPromptEdit->setText(cfg.system_prompt);
    prePromptEdit->setText(cfg.pre_prompt);
    chkGlossary->setChecked(cfg.enable_glossary);
    
    // åŠ è½½æœ¯è¯­è¡¨å†å²è®°å½• / Load glossary history
    glossaryCombo->clear();
    if (!cfg.glossary_history.isEmpty()) {
        glossaryCombo->addItems(cfg.glossary_history);
    }
    
    // è®¾ç½®å½“å‰æœ¯è¯­è¡¨è·¯å¾„ / Set current glossary path
    if (!cfg.glossary_path.isEmpty()) {
        int index = glossaryCombo->findText(cfg.glossary_path);
        if (index != -1) {
            glossaryCombo->setCurrentIndex(index);
        } else {
            addToGlossaryHistory(cfg.glossary_path);
        }
    }
    
    // è®¾ç½®å½“å‰è¯­è¨€ / Set current language
    m_currentLang = cfg.language;
}

/**
 * ä»UIè·å–é…ç½®
 * Get configuration from UI
 * @return åº”ç”¨é…ç½®å¯¹è±¡ / Application configuration object
 */
AppConfig MainWindow::getUiConfig() {
    AppConfig cfg;
    
    // ä»UIæ§ä»¶è·å–å€¼ / Get values from UI controls
    cfg.api_address = apiAddressCombo->currentText();
    cfg.api_key = apiKeyEdit->text();
    cfg.model_name = modelCombo->currentText();
    cfg.port = portEdit->text().toInt();
    cfg.temperature = tempSpin->value();
    cfg.context_num = contextSpin->value();
    cfg.max_threads = threadSpin->value();
    cfg.system_prompt = systemPromptEdit->toPlainText();
    cfg.pre_prompt = prePromptEdit->text();
    cfg.enable_glossary = chkGlossary->isChecked();
    
    cfg.glossary_path = glossaryCombo->currentText();
    
    // ä¿å­˜æœ¯è¯­è¡¨å†å²è®°å½• / Save glossary history
    QStringList history;
    for(int i = 0; i < glossaryCombo->count(); ++i) {
        history << glossaryCombo->itemText(i);
    }
    cfg.glossary_history = history;

    // ä¿å­˜å½“å‰è¯­è¨€ / Save current language
    cfg.language = m_currentLang;
    
    return cfg;
}

/**
 * åˆ‡æ¢æ§ä»¶çŠ¶æ€ï¼ˆæœåŠ¡è¿è¡Œæ—¶ç¦ç”¨éƒ¨åˆ†æ§ä»¶ï¼‰
 * Toggle control states (disable some controls when service is running)
 * @param running æ˜¯å¦æ­£åœ¨è¿è¡Œ / Whether service is running
 */
void MainWindow::toggleControls(bool running) {
    // è®¾ç½®æŒ‰é’®çŠ¶æ€ / Set button states
    startBtn->setEnabled(!running);
    stopBtn->setEnabled(running);
    
    // è®¾ç½®APIç›¸å…³æ§ä»¶çŠ¶æ€ / Set API related control states
    apiAddressCombo->setEnabled(!running);
    apiKeyEdit->setEnabled(!running);
    
    // è®¾ç½®æœåŠ¡å™¨å‚æ•°æ§ä»¶çŠ¶æ€ / Set server parameter control states
    portEdit->setEnabled(!running);
    threadSpin->setEnabled(!running);
    
    // è®¾ç½®æœ¯è¯­è¡¨ç›¸å…³æ§ä»¶çŠ¶æ€ / Set glossary related control states
    chkGlossary->setEnabled(!running);
    glossaryCombo->setEnabled(!running);
    btnSelectGlossary->setEnabled(!running);
    
    // è®¾ç½®è‡ªåŠ¨ç¿»è¯‘æŒ‰é’®çŠ¶æ€ / Set auto translation button state
    if(btnOpenAuto) btnOpenAuto->setEnabled(!running); 
    
    // è®¾ç½®HUDæŒ‰é’®çŠ¶æ€ / Set HUD button state
    hudBtn->setEnabled(running);
}

/**
 * å¯åŠ¨æŒ‰é’®ç‚¹å‡»å¤„ç†
 * Start button click handler
 */
void MainWindow::onStartClicked() {
    // è·å–UIé…ç½®å¹¶æ›´æ–°æœåŠ¡å™¨é…ç½® / Get UI configuration and update server configuration
    AppConfig cfg = getUiConfig();
    server->updateConfig(cfg);
    
    // å¯åŠ¨æœåŠ¡å™¨ / Start server
    server->startServer();
    
    // åˆ‡æ¢æ§ä»¶çŠ¶æ€ / Toggle control states
    toggleControls(true); 
}

/**
 * åœæ­¢æŒ‰é’®ç‚¹å‡»å¤„ç†
 * Stop button click handler
 */
void MainWindow::onStopClicked() {
    // åœæ­¢æœåŠ¡å™¨ / Stop server
    server->stopServer();
    
    // åˆ‡æ¢æ§ä»¶çŠ¶æ€ / Toggle control states
    toggleControls(false); 
}

/**
 * æ—¥å¿—æ¶ˆæ¯å¤„ç†
 * Log message handler
 * @param msg æ—¥å¿—æ¶ˆæ¯ / Log message
 */
void MainWindow::onLogMessage(QString msg) {
    // æ·»åŠ æ¶ˆæ¯åˆ°æ—¥å¿—åŒºåŸŸ / Add message to log area
    logArea->append(msg);
    
    // é™åˆ¶æ—¥å¿—è¡Œæ•°ï¼ˆé¿å…å†…å­˜å ç”¨è¿‡å¤§ï¼‰ / Limit log lines (avoid excessive memory usage)
    const int MAX_LOG_LINES = 2000;
    if (logArea->document()->blockCount() > MAX_LOG_LINES) {
        QTextCursor cursor(logArea->document());
        cursor.movePosition(QTextCursor::Start);
        
        // åˆ é™¤å‰500è¡Œ / Delete first 500 lines
        for(int i = 0; i < 500; ++i) {
            cursor.movePosition(QTextCursor::NextBlock, QTextCursor::KeepAnchor);
        }
        cursor.removeSelectedText();
    }
}

/**
 * ä¿å­˜é…ç½®æŒ‰é’®ç‚¹å‡»å¤„ç†
 * Save configuration button click handler
 */
void MainWindow::onSaveConfig() {
    // æ‰“å¼€æ–‡ä»¶ä¿å­˜å¯¹è¯æ¡† / Open file save dialog
    QString fileName = QFileDialog::getSaveFileName(this, STR_SAVE[m_currentLang], "config.ini", "Config Files (*.ini)");
    
    // å¦‚æœé€‰æ‹©äº†æ–‡ä»¶ï¼Œä¿å­˜é…ç½® / If file selected, save configuration
    if (!fileName.isEmpty()) {
        ConfigManager::saveConfig(getUiConfig(), fileName);
        logArea->append(QString(LOG_CFG_SAVED[m_currentLang]) + fileName);
    }
}

/**
 * åŠ è½½é…ç½®æŒ‰é’®ç‚¹å‡»å¤„ç†
 * Load configuration button click handler
 */
void MainWindow::onLoadConfig() {
    // æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡† / Open file selection dialog
    QString fileName = QFileDialog::getOpenFileName(this, STR_LOAD[m_currentLang], "", "Config Files (*.ini)");
    
    // å¦‚æœé€‰æ‹©äº†æ–‡ä»¶ï¼ŒåŠ è½½é…ç½®å¹¶æ›´æ–°UI / If file selected, load configuration and update UI
    if (!fileName.isEmpty()) {
        AppConfig cfg = ConfigManager::loadConfig(fileName);
        
        // æ›´æ–°UIæ§ä»¶å€¼ / Update UI control values
        apiAddressCombo->setCurrentText(cfg.api_address);
        apiKeyEdit->setText(cfg.api_key);
        modelCombo->setCurrentText(cfg.model_name);
        portEdit->setText(QString::number(cfg.port));
        tempSpin->setValue(cfg.temperature);
        contextSpin->setValue(cfg.context_num);
        threadSpin->setValue(cfg.max_threads);
        systemPromptEdit->setText(cfg.system_prompt);
        prePromptEdit->setText(cfg.pre_prompt);
        chkGlossary->setChecked(cfg.enable_glossary);
        
        // åŠ è½½æœ¯è¯­è¡¨å†å²è®°å½• / Load glossary history
        glossaryCombo->clear();
        if (!cfg.glossary_history.isEmpty()) {
            glossaryCombo->addItems(cfg.glossary_history);
        }
        
        // è®¾ç½®å½“å‰æœ¯è¯­è¡¨è·¯å¾„ / Set current glossary path
        if (!cfg.glossary_path.isEmpty()) {
            int index = glossaryCombo->findText(cfg.glossary_path);
            if (index != -1) glossaryCombo->setCurrentIndex(index);
            else addToGlossaryHistory(cfg.glossary_path);
        }
        
        // æ·»åŠ åŠ è½½æˆåŠŸæ—¥å¿— / Add load success log
        logArea->append(QString(LOG_CFG_LOADED[m_currentLang]) + fileName);
    }
}

/**
 * å¯¼å‡ºæ—¥å¿—æŒ‰é’®ç‚¹å‡»å¤„ç†
 * Export log button click handler
 */
void MainWindow::onExportLog() {
    // è®¾ç½®å¯¼å‡ºæ–‡ä»¶å / Set export file name
    QString fileName = "run_log.txt";
    QFile file(fileName);
    
    // æ‰“å¼€æ–‡ä»¶å¹¶å†™å…¥æ—¥å¿—å†…å®¹ / Open file and write log content
    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream out(&file);
        
        // è®¾ç½®UTF-8ç¼–ç  / Set UTF-8 encoding
        #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
            out.setEncoding(QStringConverter::Utf8);
        #else
            out.setCodec("UTF-8");
        #endif
        
        // å†™å…¥æ—¥å¿—å†…å®¹ / Write log content
        out << logArea->toPlainText();
        
        // æ·»åŠ å¯¼å‡ºæˆåŠŸæ—¥å¿—æ¶ˆæ¯ / Add export success log message
        logArea->append(LOG_EXPORTED[m_currentLang]);
    }
}

/**
 * è·å–æ¨¡å‹åˆ—è¡¨
 * Fetch models list
 */
void MainWindow::onFetchModels() {
    // æ„å»ºæ¨¡å‹åˆ—è¡¨è¯·æ±‚URL / Build models list request URL
    QString url = apiAddressCombo->currentText();
    
    // ç¡®ä¿URLæ ¼å¼æ­£ç¡® / Ensure correct URL format
    if(url.endsWith("/")) url.chop(1);
    url += "/models";
    
    // åˆ›å»ºç½‘ç»œè®¿é—®ç®¡ç†å™¨ / Create network access manager
    QNetworkAccessManager *mgr = new QNetworkAccessManager(this);
    QNetworkRequest req(url);
    
    // è®¾ç½®æˆæƒå¤´ï¼ˆæ”¯æŒå¤škeyæ ¼å¼ï¼‰ / Set authorization header (support multi-key format)
    QString key = apiKeyEdit->text().split(',')[0].trimmed();
    req.setRawHeader("Authorization", ("Bearer " + key).toUtf8());
    
    // å‘é€GETè¯·æ±‚ / Send GET request
    QNetworkReply *reply = mgr->get(req);
    
    // è¯·æ±‚å®Œæˆå¤„ç† / Request completion handling
    connect(reply, &QNetworkReply::finished, [this, reply, mgr](){
        if(reply->error() == QNetworkReply::NoError) {
            try {
                // è§£æJSONå“åº” / Parse JSON response
                auto jsonDoc = nlohmann::json::parse(reply->readAll().toStdString());
                
                // æ¸…ç©ºç°æœ‰æ¨¡å‹åˆ—è¡¨ / Clear existing model list
                modelCombo->clear();
                
                // æ·»åŠ æ–°æ¨¡å‹åˆ°ä¸‹æ‹‰æ¡† / Add new models to combobox
                for(const auto& item : jsonDoc["data"]) {
                    modelCombo->addItem(QString::fromStdString(item["id"]));
                }
                
                // æ·»åŠ æˆåŠŸæ—¥å¿— / Add success log
                logArea->append(LOG_FETCH_SUCCESS[m_currentLang]);
            } catch(...) {
                // è§£æé”™è¯¯å¤„ç† / Parse error handling
                logArea->append(LOG_PARSE_ERR[m_currentLang]);
            }
        } else {
            // è¯·æ±‚å¤±è´¥å¤„ç† / Request failure handling
            logArea->append(QString(LOG_FETCH_FAIL[m_currentLang]) + reply->errorString());
        }
        
        // æ¸…ç†èµ„æº / Clean up resources
        reply->deleteLater();
        mgr->deleteLater();
    });
}

/**
 * æµ‹è¯•é…ç½®æŒ‰é’®ç‚¹å‡»å¤„ç†
 * Test configuration button click handler
 */
void MainWindow::onTestConfig() {
    // æ·»åŠ æµ‹è¯•å¼€å§‹æ—¥å¿— / Add test start log
    logArea->append(LOG_TEST_START[m_currentLang]);
    
    // è§£æAPIå¯†é’¥ï¼ˆæ”¯æŒå¤šä¸ªå¯†é’¥ï¼‰ / Parse API keys (support multiple keys)
    QStringList keys = apiKeyEdit->text().split(',', Qt::SkipEmptyParts);
    
    // æ£€æŸ¥æ˜¯å¦æœ‰APIå¯†é’¥ / Check if API keys exist
    if (keys.isEmpty()) {
        logArea->append(LOG_NO_KEY[m_currentLang]);
        return;
    }
    
    // æ„å»ºæµ‹è¯•è¯·æ±‚URL / Build test request URL
    QString url = apiAddressCombo->currentText();
    
    // ç¡®ä¿URLæ ¼å¼æ­£ç¡® / Ensure correct URL format
    if(url.endsWith("/")) url.chop(1);
    url += "/chat/completions";
    
    // è·å–å½“å‰é€‰æ‹©çš„æ¨¡å‹ / Get currently selected model
    QString model = modelCombo->currentText();

    // æµ‹è¯•æ¯ä¸ªAPIå¯†é’¥ / Test each API key
    for (int i = 0; i < keys.size(); ++i) {
        QString key = keys[i].trimmed();
        
        // åˆ›å»ºå¯†é’¥æ©ç ï¼ˆä¿æŠ¤éšç§ï¼‰ / Create key mask (privacy protection)
        QString keyMasked = (key.length() > 8) ? ("..." + key.right(8)) : key;
        
        // åˆ›å»ºç½‘ç»œè®¿é—®ç®¡ç†å™¨ / Create network access manager
        QNetworkAccessManager *mgr = new QNetworkAccessManager(this);
        QNetworkRequest req(url);
        
        // è®¾ç½®è¯·æ±‚å¤´ / Set request headers
        req.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
        req.setRawHeader("Authorization", ("Bearer " + key).toUtf8());
        
        // æ„å»ºæµ‹è¯•è¯·æ±‚JSON / Build test request JSON
        nlohmann::json j;
        j["model"] = model.toStdString();
        j["messages"] = nlohmann::json::array({{{"role", "user"}, {"content", "Hi"}}});
        j["max_tokens"] = 5;
        
        // å‘é€POSTè¯·æ±‚ / Send POST request
        QNetworkReply *reply = mgr->post(req, QByteArray::fromStdString(j.dump()));
        
        // è¯·æ±‚å®Œæˆå¤„ç† / Request completion handling
        connect(reply, &QNetworkReply::finished, [this, reply, mgr, keyMasked, i](){
            if(reply->error() == QNetworkReply::NoError) {
                // æµ‹è¯•é€šè¿‡ / Test passed
                logArea->append(QString("âœ… Key-%1 (%2): %3").arg(i+1).arg(keyMasked).arg(LOG_PASS[m_currentLang]));
            } else {
                // æµ‹è¯•å¤±è´¥ / Test failed
                logArea->append(QString("âŒ Key-%1 (%2): %3 - %4").arg(i+1).arg(keyMasked).arg(LOG_FAIL[m_currentLang]).arg(reply->errorString()));
            }
            
            // æ¸…ç†èµ„æº / Clean up resources
            reply->deleteLater();
            mgr->deleteLater();
        });
    }
}

/**
 * æ›´æ–°Tokenæ˜¾ç¤º
 * Update token display
 * @param total æ€»tokenæ•° / Total tokens
 * @param prompt è¾“å…¥tokenæ•° / Input tokens
 * @param completion è¾“å‡ºtokenæ•° / Output tokens
 */
void MainWindow::updateTokenDisplay(long long total, long long prompt, long long completion) {
    // æ›´æ–°æ€»tokenæ˜¾ç¤º / Update total token display
    lblTokens->setText(QString("%1 %2").arg(STR_TOKENS[m_currentLang]).arg(total));
    
    // æ›´æ–°è¯¦ç»†æç¤ºä¿¡æ¯ / Update detailed tooltip information
    lblTokens->setToolTip(QString("Input: %1\nOutput: %2").arg(prompt).arg(completion));
}

/**
 * æ¸…é™¤ä¸Šä¸‹æ–‡æŒ‰é’®ç‚¹å‡»å¤„ç†
 * Clear context button click handler
 */
void MainWindow::onClearContext() {
    // æ¸…é™¤æ‰€æœ‰å¯¹è¯ä¸Šä¸‹æ–‡ / Clear all conversation contexts
    server->clearAllContexts();
}

/**
 * åˆ‡æ¢åˆ°HUDæ¨¡å¼
 * Switch to HUD mode
 */
void MainWindow::switchToHud() {
    // æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å­˜åœ¨ / Check if server exists
    if (!server) return;
    
    // åˆ›å»ºæ·¡å‡ºåŠ¨ç”» / Create fade out animation
    QPropertyAnimation *anim = new QPropertyAnimation(this, "windowOpacity");
    anim->setDuration(300);
    anim->setStartValue(1.0);
    anim->setEndValue(0.0);
    
    // åŠ¨ç”»å®Œæˆå¤„ç† / Animation completion handling
    connect(anim, &QPropertyAnimation::finished, [this](){
        // éšè—ä¸»çª—å£ / Hide main window
        this->hide();
        
        // è®¾ç½®HUDçª—å£ä½ç½®å¹¶æ˜¾ç¤º / Set HUD window position and show
        m_hudWindow->move(this->geometry().topRight() - QPoint(280, -20)); 
        m_hudWindow->show();
        
        // è®¾ç½®HUDçª—å£çŠ¶æ€ / Set HUD window status
        m_hudWindow->setStatus(false);
        
        // æ›´æ–°HUDçª—å£Tokenæ˜¾ç¤º / Update HUD window token display
        m_hudWindow->updateTokens(m_tokenManager->getTotal());
    });
    
    // å¯åŠ¨åŠ¨ç”» / Start animation
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}

/**
 * ä»HUDæ¨¡å¼æ¢å¤ä¸»çª—å£
 * Restore main window from HUD mode
 */
void MainWindow::restoreFromHud() {
    // éšè—HUDçª—å£ / Hide HUD window
    m_hudWindow->hide();
    
    // è®¾ç½®ä¸»çª—å£é€æ˜åº¦å¹¶æ˜¾ç¤º / Set main window opacity and show
    this->setWindowOpacity(0.0);
    this->show();
    
    // åˆ›å»ºæ·¡å…¥åŠ¨ç”» / Create fade in animation
    QPropertyAnimation *anim = new QPropertyAnimation(this, "windowOpacity");
    anim->setDuration(300);
    anim->setStartValue(0.0);
    anim->setEndValue(1.0);
    
    // å¯åŠ¨åŠ¨ç”» / Start animation
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}

/**
 * æœåŠ¡å™¨å·¥ä½œå¼€å§‹å¤„ç†
 * Server work started handler
 */
void MainWindow::onServerWorkStarted() {
    // å¦‚æœHUDçª—å£å¯è§ï¼Œè®¾ç½®å¿™ç¢ŒçŠ¶æ€ / If HUD window is visible, set busy status
    if (m_hudWindow && m_hudWindow->isVisible()) {
        m_hudWindow->setStatus(true);
    }
}

/**
 * æœåŠ¡å™¨å·¥ä½œå®Œæˆå¤„ç†
 * Server work finished handler
 * @param success æ˜¯å¦æˆåŠŸ / Whether operation succeeded
 */
void MainWindow::onServerWorkFinished(bool success) {
    // å¦‚æœHUDçª—å£å¯è§ï¼Œè®¾ç½®ç©ºé—²çŠ¶æ€ / If HUD window is visible, set idle status
    if (m_hudWindow && m_hudWindow->isVisible()) {
        m_hudWindow->setStatus(false, !success); 
    }
}