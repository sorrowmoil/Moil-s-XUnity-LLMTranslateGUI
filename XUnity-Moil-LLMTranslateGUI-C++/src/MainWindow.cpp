/**
 * MainWindow.cpp - Moil's XUnity LLM Translator GUI Implementation
 * MainWindow.cpp - Moilçš„XUnityå¤§æ¨¡å‹ç¿»è¯‘å™¨GUIå®ç°
 * 
 * Final Perfect Version by CAN.
 * Base: MainWindow.txt (Preferred UI/UX)
 * Core Logic: 1.txt (Robust Hot Reload & Layout Fixes)
 * Updated: Logic Fixed - User Lock Override (Session Persistence)
 */

#include "MainWindow.h"
#include "json.hpp"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QGroupBox>
#include <QFileDialog>
#include <QMessageBox>
#include <QApplication>
#include <QFile>
#include <QTextStream>
#include <QCloseEvent>
#include <QStyleFactory>
#include <QPixmap>
#include <QMenu>
#include <QScrollBar>
#include <QGraphicsOpacityEffect>
#include <QPropertyAnimation>
#include <QListView> 
#include <QDesktopServices>
#include <QUrl>
#include <QFileInfo>

// ==========================================
// ğŸŒ å¤šè¯­è¨€å­—å…¸å®šä¹‰ (UI Text)
// ==========================================

// Window titles / çª—å£æ ‡é¢˜
const char* STR_TITLE[] = {"Moil's XUnity LLM Translator", "Moilçš„XUnityå¤§æ¨¡å‹ç¿»è¯‘GUI"};

// Configuration section titles / é…ç½®éƒ¨åˆ†æ ‡é¢˜
const char* STR_API_CFG[] = {"API Configuration", "API é…ç½®"};
const char* STR_LOG_AREA[] = {"Runtime Logs", "è¿è¡Œæ—¥å¿—"};

// API configuration related text / APIé…ç½®ç›¸å…³æ–‡æœ¬
const char* STR_API_ADDR[] = {"API Address:", "API åœ°å€:"};
const char* STR_API_KEY[] = {"API Key:", "API å¯†é’¥:"};
const char* STR_MODEL[] = {"Model Name:", "æ¨¡å‹åç§°:"};
const char* STR_FETCH[] = {"Fetch", "è·å–"};

// Server parameter text / æœåŠ¡å™¨å‚æ•°æ–‡æœ¬
const char* STR_PORT[] = {"Port:", "ç«¯å£:"};
const char* STR_THREAD[] = {"Threads:", "çº¿ç¨‹:"};
const char* STR_TEMP[] = {"Temp:", "æ¸©åº¦:"};
const char* STR_CTX[] = {"Context:", "ä¸Šä¸‹æ–‡:"};

// Prompt related text / æç¤ºè¯ç›¸å…³æ–‡æœ¬
const char* STR_SYS_PROMPT[] = {"System Prompt:", "ç³»ç»Ÿæç¤º:"};
const char* STR_PRE_PROMPT[] = {"Pre-Prompt:", "å‰ç½®æ–‡æœ¬:"};

// Control button text / æ§åˆ¶æŒ‰é’®æ–‡æœ¬
const char* STR_START[] = {"Start Service", "å¯åŠ¨æœåŠ¡"};
const char* STR_RELOAD[] = {"Hot Reload", "çƒ­é‡è½½é…ç½®"}; 
const char* STR_STOP[] = {"Stop Service", "åœæ­¢æœåŠ¡"};
const char* STR_HUD[] = {"HUD Mode", "HUD æ¨¡å¼"};
const char* STR_TEST[] = {"Test Config", "æµ‹è¯•é…ç½®"};
const char* STR_LOAD[] = {"Load Config", "è¯»å–é…ç½®"};
const char* STR_SAVE[] = {"Save Config", "ä¿å­˜é…ç½®"};
const char* STR_EXPORT[] = {"Export Log", "å¯¼å‡ºæ—¥å¿—"};

// Theme and language text / ä¸»é¢˜å’Œè¯­è¨€æ–‡æœ¬
const char* STR_THEME_LIGHT[] = {"Light Mode", "åˆ‡æ¢äº®è‰²"};
const char* STR_THEME_DARK[] = {"Dark Mode", "åˆ‡æ¢æš—è‰²"};
const char* STR_LANG_BTN[] = {"ä¸­æ–‡", "English"}; 

// Glossary related text / æœ¯è¯­è¡¨ç›¸å…³æ–‡æœ¬
const char* STR_GLOSSARY[] = {"Glossary:", "æœ¯è¯­è¡¨:"};
const char* STR_CHK_GLOSSARY[] = {"Self-Evolve", "å¯ç”¨è‡ªè¿›åŒ–"};
const char* STR_CLEAR_LOG[] = {"Clear Log", "æ¸…ç©ºæ—¥å¿—"};
const char* STR_REMOVE_PATH[] = {"Remove Current Path", "ç§»é™¤å½“å‰è·¯å¾„"};
const char* STR_CLEAR_HISTORY[] = {"Clear All History", "æ¸…ç©ºå†å²è®°å½•"};

// Token statistics text / Tokenç»Ÿè®¡æ–‡æœ¬
const char* STR_TOKENS[] = {"Tokens:", "æ¶ˆè€—:"};
const char* TIP_TOKENS[] = {"Total Usage (Prompt + Completion)", "æœ¬æ¬¡è¿è¡Œæ€»æ¶ˆè€— (è¾“å…¥+è¾“å‡º)"};

// Context clearing related text / ä¸Šä¸‹æ–‡æ¸…é™¤ç›¸å…³æ–‡æœ¬
const char* STR_CLEAR_CTX[] = {"Clear", "æ¸…ç©º"};
const char* TIP_CLEAR_CTX[] = {"Clear Context", "æ¸…é™¤å†å²å¯¹è¯è®°å¿†"};

// New button text / æ–°æŒ‰é’®æ–‡æœ¬
const char* STR_BTN_AUTO[] = {"Edit", "ç¼–è¾‘"};
const char* TIP_BTN_AUTO[] = {
    "Open _AutoGeneratedTranslations.txt in same folder", 
    "æ‰“å¼€åŒç›®å½•ä¸‹çš„ _AutoGeneratedTranslations.txt (è‡ªåŠ¨ç¿»è¯‘ç»“æœ)"
};

// 
const char* STR_LOCK_SYS[] = {"Lock", "é”å®š"};
const char* TIP_LOCK_SYS[] = {
    "Lock System Prompt to prevent overwriting when loading config", 
    "é”å®šç³»ç»Ÿæç¤ºè¯ï¼Œé˜²æ­¢åœ¨è¯»å–é…ç½®æ—¶è¢«è¦†ç›–"
};

// ==========================================
// ğŸ“ æ—¥å¿—æ¶ˆæ¯å®šä¹‰ (Logs - Merged for Completeness)
// ==========================================

const char* LOG_TEST_START[] = {"ğŸ“¡ === Testing API Keys ===", "ğŸ“¡ === å¼€å§‹æµ‹è¯•æ‰€æœ‰ API Key ==="};
const char* LOG_NO_KEY[] = {"âŒ No API Key", "âŒ æœªæ‰¾åˆ° API Key"};
const char* LOG_PASS[] = {"Pass", "æµ‹è¯•é€šè¿‡"};
const char* LOG_FAIL[] = {"Fail", "å¤±è´¥"};
const char* LOG_FETCH_SUCCESS[] = {"Fetch Models Success", "æ¨¡å‹åˆ—è¡¨è·å–æˆåŠŸ"};
const char* LOG_FETCH_FAIL[] = {"Fetch Failed: ", "è·å–å¤±è´¥: "};
const char* LOG_PARSE_ERR[] = {"Parse Error", "è§£æé”™è¯¯"};
const char* LOG_CFG_SAVED[] = {"âš™ï¸ Config Saved: ", "âš™ï¸ é…ç½®å·²ä¿å­˜: "};
const char* LOG_CFG_LOADED[] = {"ğŸ“™ Config Loaded: ", "ğŸ“™ é…ç½®å·²åŠ è½½: "};
const char* LOG_EXPORTED[] = {"âœ’ï¸ Log Exported to run_log.txt", "âœ’ï¸ æ—¥å¿—å·²å¯¼å‡ºåˆ° run_log.txt"};

// ğŸ”¥ Enhanced Hot Reload Logs (From 1.txt) / å¢å¼ºçš„çƒ­é‡è½½æ—¥å¿—ï¼ˆæ¥è‡ª1.txtï¼‰
const char* LOG_RELOADED[] = {"âš¡ Config Hot Reloaded!", "âš¡ é…ç½®å·²çƒ­é‡è½½ç”Ÿæ•ˆï¼"};
const char* LOG_MODEL_SWITCH[] = {"ğŸ”„ Model Switch: [%1] -> [%2]", "ğŸ”„ æ¨¡å‹åˆ‡æ¢: [%1] -> [%2]"};
const char* LOG_MODEL_SAME[] = {"âš¡ Reloaded (Model: %1)", "âš¡ çƒ­é‡è½½æˆåŠŸ (æ¨¡å‹: %1)"};
const char* LOG_AUTO_TESTING[] = {"ğŸ› ï¸ Auto-testing new config...", "ğŸ› ï¸ æ­£åœ¨è‡ªåŠ¨æµ‹è¯•æ–°é…ç½®..."};

// ==========================================
// ğŸ’¡ è¯¦ç»†å·¥å…·æç¤º (Detailed Tooltips)
// ==========================================

const char* TIP_PORT[] = {
    "Local Listening Port (Restart required to change)\nEnsure XUnity Endpoint is set to http://localhost:port",
    "æœ¬åœ°ç›‘å¬ç«¯å£ (ä¿®æ”¹éœ€é‡å¯æœåŠ¡)\nè¯·ç¡®ä¿ XUnity é…ç½®æ–‡ä»¶ Endpoint è®¾ç½®ä¸º http://localhost:ç«¯å£å·"
};

const char* TIP_THREAD[] = {
    "Concurrent Threads\nRecommended: Depends on your CPU\nNote: Can speed up translation to some extent, too many may cause system lag",
    "å¹¶å‘çº¿ç¨‹æ•° (Max Threads)\nå»ºè®®å€¼: å–å†³äºä½ ç”µè„‘çš„çº¿ç¨‹æ•°\næ³¨æ„: ä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥åŠ å¿«ç¿»è¯‘å·¥ä½œï¼Œè¿‡å¤šä¼šå¯¼è‡´ç³»ç»Ÿå¡é¡¿"
};

const char* TIP_TEMP[] = {
    "Sampling Temperature\n0.0-0.3: Strict\n0.7-1.0: Standard\n>1.0: Creative/Random",
    "é‡‡æ ·æ¸©åº¦ (Temperature)\n0.0-0.3: ä¸¥è°¨\n0.7-1.0: æ ‡å‡†\n>1.0: éšæœº/åˆ›é€ æ€§"
};

const char* TIP_CTX[] = {
    "Context Memory\nNumber of history turns to carry.\nNote: More context consumes more tokens.",
    "ä¸Šä¸‹æ–‡è®°å¿† (Context)\næºå¸¦çš„å†å²å¯¹è¯è½®æ•°ã€‚\næ³¨æ„ï¼šä¸Šä¸‹æ–‡è¶Šå¤šï¼Œæ¶ˆè€— Token è¶Šå¤šã€‚"
};

const char* TIP_GLOSSARY[] = {
    "Select XUnity's _Substitutions.txt.\nLLM will reference and append to it.",
    "é€‰æ‹© XUnity çš„ _Substitutions.txt æ–‡ä»¶ã€‚\nLLM å°†è‡ªåŠ¨å‚è€ƒå¹¶è¡¥å……è¯¥æ–‡ä»¶ã€‚"
};

const char* TIP_COMBO_MAIN[] = {
    "Enter API Address or select from list.\nMust support /v1/chat/completions format.",
    "åœ¨æ­¤è¾“å…¥ API åœ°å€ï¼Œæˆ–ä»ä¸‹æ‹‰åˆ—è¡¨ä¸­é€‰æ‹©ä¸»æµæœåŠ¡å•†ã€‚\næ‰€æœ‰åœ°å€å¿…é¡»å…¼å®¹ OpenAI æ¥å£æ ¼å¼ (/v1/chat/completions)ã€‚"
};

// ==========================================
// âš™ï¸ API Presets
// ==========================================

struct ApiPresetDef {
    const char* url;          // API URL / APIåœ°å€
    const char* tips[2];      // Tooltip text in both languages / åŒè¯­å·¥å…·æç¤ºæ–‡æœ¬
};

const ApiPresetDef PRESETS_DATA[] = {
    {"https://api.openai.com/v1", {"OpenAI Official API", "OpenAI å®˜æ–¹æ¥å£"}},
    {"https://api.deepseek.com", {"DeepSeek Official API", "DeepSeek å®˜æ–¹æ¥å£"}},
    {"https://api.x.ai/v1", {"Grok (xAI) Official API", "Grok (xAI) å®˜æ–¹æ¥å£"}},
    {"https://api.siliconflow.cn/v1", {"SiliconFlow", "ç¡…åŸºæµåŠ¨ (SiliconFlow)"}},
    {"https://openrouter.ai/api/v1", {"OpenRouter Aggregator", "OpenRouter èšåˆå¹³å°"}},
    {"https://generativelanguage.googleapis.com/v1beta/openai", {"Google Gemini", "Google Gemini (OpenAI å…¼å®¹ç«¯ç‚¹)"}},
    {"http://localhost:11434/v1", {"Ollama Local Service", "Ollama æœ¬åœ°æœåŠ¡"}},
    {"http://localhost:1234/v1", {"LM Studio Local Service", "LM Studio æœ¬åœ°æœåŠ¡"}}
};

// ==========================================
// ğŸš€ Implementation
// ==========================================

MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) {
    // Initialize member variables / åˆå§‹åŒ–æˆå‘˜å˜é‡
    m_isClosing = false;          // Flag to prevent multiple close events / é˜²æ­¢å¤šæ¬¡å…³é—­äº‹ä»¶çš„æ ‡å¿—
    m_isDarkTheme = true;         // Default to dark theme / é»˜è®¤ä¸ºæš—è‰²ä¸»é¢˜
    m_currentLang = 1;            // Default to Chinese / é»˜è®¤ä¸­æ–‡
    m_isServerRunning = false;    // Server is not running initially / æœåŠ¡å™¨åˆå§‹çŠ¶æ€ä¸ºæœªè¿è¡Œ

    // Initial size - restored to compact width / åˆå§‹å¤§å° - æ¢å¤ä¸ºç´§å‡‘å®½åº¦
    resize(400, 800);

    // Create core components / åˆ›å»ºæ ¸å¿ƒç»„ä»¶
    m_tokenManager = new TokenManager(this);
    server = new TranslationServer(this);
    m_hudWindow = new HudWindow(nullptr);
    
    // Setup user interface / è®¾ç½®ç”¨æˆ·ç•Œé¢
    setupUi();

    // Connect signals and slots / è¿æ¥ä¿¡å·å’Œæ§½
    connect(server, &TranslationServer::logMessage, this, &MainWindow::onLogMessage);
    connect(server, &TranslationServer::tokenUsageReceived, m_tokenManager, &TokenManager::addUsage);
    connect(m_tokenManager, &TokenManager::tokensUpdated, this, &MainWindow::updateTokenDisplay);

    connect(m_hudWindow, &HudWindow::requestRestore, this, &MainWindow::restoreFromHud);
    connect(m_tokenManager, &TokenManager::tokensUpdated,  [this](long long t, long long, long long){
        if(m_hudWindow) m_hudWindow->updateTokens(t);
    });
    
    connect(server, &TranslationServer::workStarted, this, &MainWindow::onServerWorkStarted);
    connect(server, &TranslationServer::workFinished, this, &MainWindow::onServerWorkFinished);

    // Load configuration and apply theme / åŠ è½½é…ç½®å¹¶åº”ç”¨ä¸»é¢˜
    loadConfigToUi();
    updateUIText();
    applyTheme(true); 

    // Fade-in animation / æ·¡å…¥åŠ¨ç”»
    setWindowOpacity(0.0);
    fadeAnim = new QPropertyAnimation(this, "windowOpacity");
    fadeAnim->setDuration(500);
    fadeAnim->setStartValue(0.0);
    fadeAnim->setEndValue(1.0);
    fadeAnim->start();
}

MainWindow::~MainWindow() {
    // Clean up resources / æ¸…ç†èµ„æº
    if (m_hudWindow) {
        m_hudWindow->close();
        delete m_hudWindow;
    }
    server->stopServer();
}

void MainWindow::closeEvent(QCloseEvent *event) {
    if (m_isClosing) {
        event->accept();
        return;
    }
    
    // Save configuration before closing / å…³é—­å‰ä¿å­˜é…ç½®
    ConfigManager::saveConfig(getUiConfig(), "config.ini");
    

    // ğŸ”¥ CAN: ç‹¬ç«‹ä¿å­˜æœ¯è¯­è¡¨é”å®šçŠ¶æ€
    QSettings sess("config.ini", QSettings::IniFormat);
    sess.setValue("Settings/lock_glossary_path", chkLockGlossary->isChecked());
    sess.sync();

    if (m_hudWindow->isVisible()) {
        m_hudWindow->close();
    }
    
    event->ignore();
    m_isClosing = true;
    fadeOutAndClose();
}

void MainWindow::fadeOutAndClose() {
    // Reverse the fade animation for smooth exit / åå‘æ·¡å‡ºåŠ¨ç”»å®ç°å¹³æ»‘é€€å‡º
    fadeAnim->setDirection(QAbstractAnimation::Backward);
    connect(fadeAnim, &QPropertyAnimation::finished, this, &QMainWindow::close);
    connect(fadeAnim, &QPropertyAnimation::finished, qApp, &QApplication::quit);
    fadeAnim->start();
}

void MainWindow::smoothSwitch(std::function<void()> changeLogic) {
    /**
     * Perform a smooth visual transition when changing UI state / åœ¨æ›´æ”¹UIçŠ¶æ€æ—¶æ‰§è¡Œå¹³æ»‘è§†è§‰è¿‡æ¸¡
     * @param changeLogic: The actual UI change to perform / è¦æ‰§è¡Œçš„å®é™…UIæ›´æ”¹é€»è¾‘
     */
    
    // Capture current screen / æ•è·å½“å‰å±å¹•
    QPixmap pixmap = this->grab();
    QLabel* overlay = new QLabel(this);
    overlay->setPixmap(pixmap);
    overlay->setGeometry(0, 0, this->width(), this->height());
    overlay->show();

    // Execute the change logic / æ‰§è¡Œæ›´æ”¹é€»è¾‘
    changeLogic();

    // Apply fade-out animation to overlay / å¯¹è¦†ç›–å±‚åº”ç”¨æ·¡å‡ºåŠ¨ç”»
    QGraphicsOpacityEffect* effect = new QGraphicsOpacityEffect(overlay);
    overlay->setGraphicsEffect(effect);

    QPropertyAnimation* anim = new QPropertyAnimation(effect, "opacity");
    anim->setDuration(300);
    anim->setStartValue(1.0);
    anim->setEndValue(0.0);
    
    connect(anim, &QPropertyAnimation::finished, overlay, &QLabel::deleteLater);
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}

void MainWindow::toggleLanguage() {
    // ğŸ’¡ 1. First save the current complete configuration copy / å…ˆä¿å­˜å½“å‰å®Œæ•´é…ç½®å‰¯æœ¬
    AppConfig currentCfg = getUiConfig(); 

    smoothSwitch([this, currentCfg](){
        // ğŸ’¡ 2. Switch language flag / åˆ‡æ¢è¯­è¨€æ ‡å¿—ä½
        m_currentLang = (m_currentLang == 0) ? 1 : 0;
        
        // ğŸ’¡ 3. Update UI text (blocker already added internally) / æ›´æ–° UI æ–‡å­—ï¼ˆå†…éƒ¨å·²åŠ  blockerï¼‰
        updateUIText();
        
        // ğŸ’¡ 4. The processing here is critical: / è¿™é‡Œçš„å¤„ç†å¾ˆå…³é”®ï¼š
        // After updateUIText finishes, we need to ensure apiAddressCombo restores correctly
        // Since we already have currentCfg, directly use its value to restore
        // updateUIText ç»“æŸåï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿ apiAddressCombo æ¢å¤æ­£ç¡®
        // æ—¢ç„¶æˆ‘ä»¬å·²ç»æœ‰äº† currentCfgï¼Œç›´æ¥ç”¨å®ƒçš„å€¼æ¢å¤
        apiAddressCombo->setCurrentText(currentCfg.api_address);

        if(themeBtn) themeBtn->setText(m_isDarkTheme ? STR_THEME_LIGHT[m_currentLang] : STR_THEME_DARK[m_currentLang]);
        toggleControls(m_isServerRunning);
        
        // ğŸ’¡ 5. Update server configuration / æ›´æ–°æœåŠ¡å™¨é…ç½®
        // At this point, currentCfg's language is still old, we need to update it before giving it to the server
        // æ­¤æ—¶ currentCfg çš„ language è¿˜æ˜¯æ—§çš„ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ–°å®ƒå†äº¤ç»™æœåŠ¡å™¨
        AppConfig finalCfg = currentCfg;
        finalCfg.language = m_currentLang;
        server->updateConfig(finalCfg);

        qApp->processEvents();
        adjustSize();
        resize(400, 800); 
    });
}

void MainWindow::toggleTheme() {
    smoothSwitch([this](){
        applyTheme(!m_isDarkTheme);
        toggleControls(m_isServerRunning);
    });
}

void MainWindow::addToGlossaryHistory(const QString& path) {
    if (path.isEmpty()) return;
    
    // Extract current history items
    QStringList items;
    for (int i = 0; i < glossaryCombo->count(); ++i) {
        items << glossaryCombo->itemText(i);
    }
    
    // Remove duplicates and add new path to top
    items.removeAll(path);
    items.insert(0, path);
    
    // Limit history size to 10 items
    while (items.size() > 10) {
        items.removeLast();
    }
    
    // Update combo box
    glossaryCombo->clear();
    glossaryCombo->addItems(items);
    glossaryCombo->setCurrentIndex(0); 
    
    // ğŸ”¥ CAN: å¼ºåˆ¶å°†å…‰æ ‡ç§»åˆ°æœ€å·¦ä¾§ (Focus on Start)
    if (glossaryCombo->lineEdit()) {
        glossaryCombo->lineEdit()->setCursorPosition(0);
    }
}

void MainWindow::onSelectGlossary() {
    QString fileName = QFileDialog::getOpenFileName(this, tr("Select Glossary"), "", "XUnity Files (*.txt);;All Files (*)");
    
    if (!fileName.isEmpty()) {
        addToGlossaryHistory(fileName); // å†…éƒ¨åº”å¤„ç† glossaryCombo->insertItem å¹¶ setCurrentText
        
        // å¦‚æœæœåŠ¡å™¨åœ¨è¿è¡Œï¼Œæ‰§è¡Œâ€œå³æ—¶ç”Ÿæ•ˆâ€é€»è¾‘
        if (m_isServerRunning && server) {
            AppConfig cfg = getUiConfig();
            server->updateConfig(cfg);
            onLogMessage(m_currentLang == 0 ? "âœ… New glossary applied." : "âœ… æ–°æœ¯è¯­è¡¨å·²åº”ç”¨ã€‚");
        }
    }
}

void MainWindow::onOpenAutoTranslations() {
    // Get current glossary file path / è·å–å½“å‰æœ¯è¯­è¡¨æ–‡ä»¶è·¯å¾„
    QString currentPath = glossaryCombo->currentText();
    if (currentPath.isEmpty()) return;

    // Construct path to auto-generated translations file / æ„é€ è‡ªåŠ¨ç”Ÿæˆçš„ç¿»è¯‘æ–‡ä»¶è·¯å¾„
    QFileInfo fi(currentPath);
    QString dir = fi.absolutePath();
    QString targetFile = dir + "/_AutoGeneratedTranslations.txt";

    QFileInfo targetFi(targetFile);
    if (!targetFi.exists()) {
        // File doesn't exist, show warning / æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ˜¾ç¤ºè­¦å‘Š
        QMessageBox::warning(this, 
            (m_currentLang == 1 ? "æ–‡ä»¶æœªæ‰¾åˆ°" : "File Not Found"), 
            (m_currentLang == 1 ? "æœªæ‰¾åˆ° _AutoGeneratedTranslations.txtã€‚\nè¯·ç¡®è®¤æ¸¸æˆæ˜¯å¦å·²ç»è¿è¡Œå¹¶ç”Ÿæˆäº†ç¿»è¯‘ã€‚" : 
            "Could not find _AutoGeneratedTranslations.txt.\nPlease ensure the game has run and generated translations."));
        return;
    }
    
    // Open file with default application / ä½¿ç”¨é»˜è®¤åº”ç”¨ç¨‹åºæ‰“å¼€æ–‡ä»¶
    QDesktopServices::openUrl(QUrl::fromLocalFile(targetFile));
}

void MainWindow::updateUIText() {
    int i = m_currentLang;

    // ğŸ’¡ Lock current API address and combo box state to prevent jumping during update
    // é”å®šå½“å‰ API åœ°å€å’Œä¸‹æ‹‰æ¡†çŠ¶æ€ï¼Œé˜²æ­¢æ›´æ–°æ—¶è·³å˜
    QString currentApi = apiAddressCombo->currentText();
    QSignalBlocker blocker(apiAddressCombo); // Block all signals triggered by modifications / é˜»æ­¢æ‰€æœ‰å› ä¿®æ”¹è€Œè§¦å‘çš„ä¿¡å·

    // Update window title / æ›´æ–°çª—å£æ ‡é¢˜
    setWindowTitle(STR_TITLE[i]);
    
    // Update group box titles / æ›´æ–°åˆ†ç»„æ¡†æ ‡é¢˜
    cfgGroup->setTitle(STR_API_CFG[i]);
    logGroup->setTitle(STR_LOG_AREA[i]);

    // Update labels / æ›´æ–°æ ‡ç­¾
    lblApiAddr->setText(STR_API_ADDR[i]);
    lblApiKey->setText(STR_API_KEY[i]);
    lblModel->setText(STR_MODEL[i]);
    fetchModelBtn->setText(STR_FETCH[i]);

    lblPort->setText(STR_PORT[i]);
    lblThread->setText(STR_THREAD[i]);
    lblTemp->setText(STR_TEMP[i]);
    lblCtx->setText(STR_CTX[i]);
    
    lblSysPrompt->setText(STR_SYS_PROMPT[i]);

    // âœ… Update new lock system prompt checkbox text / æ›´æ–°æ–°å¢é”å®šç³»ç»Ÿæç¤ºè¯å¤é€‰æ¡†æ–‡æœ¬
    chkLockSysPrompt->setText(STR_LOCK_SYS[i]);
    chkLockSysPrompt->setToolTip(TIP_LOCK_SYS[i]);

    lblPrePrompt->setText(STR_PRE_PROMPT[i]);

    clearCtxBtn->setText(STR_CLEAR_CTX[i]);
    clearCtxBtn->setToolTip(TIP_CLEAR_CTX[i]);

    lblGlossary->setText(STR_GLOSSARY[i]);
    chkGlossary->setText(STR_CHK_GLOSSARY[i]);

    // Update button text based on server state / æ ¹æ®æœåŠ¡å™¨çŠ¶æ€æ›´æ–°æŒ‰é’®æ–‡æœ¬
    if (m_isServerRunning) {
        startBtn->setText(STR_RELOAD[i]);
    } else {
        startBtn->setText(STR_START[i]);
    }

    stopBtn->setText(STR_STOP[i]);
    hudBtn->setText(STR_HUD[i]); 
    testBtn->setText(STR_TEST[i]);
    loadBtn->setText(STR_LOAD[i]);
    saveBtn->setText(STR_SAVE[i]);
    exportBtn->setText(STR_EXPORT[i]);
    langBtn->setText(STR_LANG_BTN[i]);

    // Update glossary open button / æ›´æ–°æœ¯è¯­è¡¨æ‰“å¼€æŒ‰é’®
    if (btnOpenAuto) {
        btnOpenAuto->setText(STR_BTN_AUTO[i]);
        btnOpenAuto->setToolTip(TIP_BTN_AUTO[i]);
    }

    // Update tooltips / æ›´æ–°å·¥å…·æç¤º
    portEdit->setToolTip(TIP_PORT[i]);
    lblPort->setToolTip(TIP_PORT[i]);
    threadSpin->setToolTip(TIP_THREAD[i]);
    lblThread->setToolTip(TIP_THREAD[i]);
    tempSpin->setToolTip(TIP_TEMP[i]);
    lblTemp->setToolTip(TIP_TEMP[i]);
    contextSpin->setToolTip(TIP_CTX[i]);
    lblCtx->setToolTip(TIP_CTX[i]);

    lblGlossary->setToolTip(TIP_GLOSSARY[i]);
    chkGlossary->setToolTip(TIP_GLOSSARY[i]);
    btnSelectGlossary->setToolTip(TIP_GLOSSARY[i]);
    if (glossaryCombo) glossaryCombo->setToolTip(TIP_GLOSSARY[i]);
    
    hudBtn->setToolTip(i==0 ? "Switch to Mini-HUD mode" : "åˆ‡æ¢è‡³è¿·ä½ æ‚¬æµ®çª—æ¨¡å¼");
    
    // Update API address combo box tooltips / æ›´æ–°APIåœ°å€ç»„åˆæ¡†å·¥å…·æç¤º
    if (apiAddressCombo) {
        apiAddressCombo->setToolTip(TIP_COMBO_MAIN[i]);
        for (int k = 0; k < apiAddressCombo->count(); ++k) {
            QString itemUrl = apiAddressCombo->itemText(k);
            for (const auto& preset : PRESETS_DATA) {
                if (itemUrl == preset.url) {
                    apiAddressCombo->setItemData(k, preset.tips[i], Qt::ToolTipRole);
                    break;
                }
            }
        }
        // ğŸ’¡ Force restore original text to prevent changing to preset first item or random item
        // å¼ºåˆ¶æ¢å¤åŸæ¥çš„æ–‡æœ¬ï¼Œé˜²æ­¢å˜æˆé¢„è®¾çš„ç¬¬ä¸€é¡¹æˆ–éšæœºé¡¹
        apiAddressCombo->setCurrentText(currentApi);
    }

    // ğŸ’¡ Fix: Restore data from properties and refresh display
    // ä¿®æ­£ï¼šä»å±æ€§ä¸­æ¢å¤æ•°æ®å¹¶åˆ·æ–°æ˜¾ç¤º
    long long t = lblTokens->property("total").toLongLong();
    long long p = lblTokens->property("prompt").toLongLong();
    long long c = lblTokens->property("completion").toLongLong();
    
    // Call modified function to refresh text and Tooltip in one go
    // è°ƒç”¨åˆšæ‰ä¿®æ”¹è¿‡çš„å‡½æ•°ï¼Œä¸€é”®åˆ·æ–°æ–‡å­—å’Œ Tooltip
    updateTokenDisplay(t, p, c);

    // Update lock glossary checkbox text / æ›´æ–°é”å®šæœ¯è¯­è¡¨å¤é€‰æ¡†æ–‡æœ¬
    chkLockGlossary->setText(STR_LOCK_SYS[i]);
    chkLockGlossary->setToolTip(i == 1 ? "é”å®šæœ¯è¯­è¡¨è·¯å¾„ï¼Œé˜²æ­¢è¯»å–é…ç½®æ—¶è¢«è¦†ç›–" : "Lock Glossary Path to prevent overwriting");
}

void MainWindow::applyTheme(bool isDark) {
    // Set Fusion style for consistent look across platforms / è®¾ç½®Fusioné£æ ¼ä»¥å®ç°è·¨å¹³å°ä¸€è‡´å¤–è§‚
    qApp->setStyle(QStyleFactory::create("Fusion"));
    
    QColor windowColor, baseColor, textColor, btnColor, highlightColor, linkColor;
    QString qssBtnBorder, qssBtnBg, qssBtnHover;
    QString dropDownBg, dropDownHover; 
    
    // Set color scheme based on theme / æ ¹æ®ä¸»é¢˜è®¾ç½®é…è‰²æ–¹æ¡ˆ
    if (isDark) {
        // Dark theme colors / æš—è‰²ä¸»é¢˜é¢œè‰²
        windowColor = QColor(30, 30, 30);    
        baseColor   = QColor(37, 37, 38);   
        textColor   = QColor(220, 220, 220); 
        btnColor    = QColor(60, 60, 60);    
        highlightColor = QColor(0, 122, 204); 
        linkColor   = QColor(86, 156, 214);
        qssBtnBorder = "#555555";
        qssBtnBg     = "#3C3C3C";
        qssBtnHover  = "#505050";
        dropDownBg    = "#C0C0C0"; 
        dropDownHover = "#FFFFFF"; 
        if(themeBtn) themeBtn->setText(STR_THEME_LIGHT[m_currentLang]);
    } else {
        // Light theme colors / äº®è‰²ä¸»é¢˜é¢œè‰²
        windowColor = QColor(240, 240, 240);
        baseColor   = QColor(255, 255, 255); 
        textColor   = QColor(0, 0, 0);
        btnColor    = QColor(225, 225, 225);
        highlightColor = QColor(0, 120, 215);
        linkColor   = QColor(0, 0, 255);
        qssBtnBorder = "#C0C0C0";
        qssBtnBg     = "#E1E1E1";
        qssBtnHover  = "#D0D0D0";
        dropDownBg    = "#4D4D4D"; 
        dropDownHover = "#2D2D2D"; 
        if(themeBtn) themeBtn->setText(STR_THEME_DARK[m_currentLang]);
    }
    
    // Apply palette colors / åº”ç”¨è°ƒè‰²æ¿é¢œè‰²
    QPalette p;
    p.setColor(QPalette::Window, windowColor);
    p.setColor(QPalette::WindowText, textColor);
    p.setColor(QPalette::Base, baseColor); 
    p.setColor(QPalette::AlternateBase, windowColor);
    p.setColor(QPalette::ToolTipBase, baseColor);
    p.setColor(QPalette::ToolTipText, textColor);
    p.setColor(QPalette::Text, textColor);
    p.setColor(QPalette::Button, btnColor);
    p.setColor(QPalette::ButtonText, textColor);
    p.setColor(QPalette::Link, linkColor);
    p.setColor(QPalette::Highlight, highlightColor);
    p.setColor(QPalette::HighlightedText, Qt::white);
    qApp->setPalette(p);
    
    // Apply CSS stylesheet for detailed styling / åº”ç”¨CSSæ ·å¼è¡¨è¿›è¡Œè¯¦ç»†æ ·å¼è®¾ç½®
    QString qss = QString(R"(
        QGroupBox { border: 1px solid %1; border-radius: 5px; margin-top: 1.2em; font-weight: bold; }
        QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; left: 10px; padding: 0 3px; color: %6; }
        QPushButton { border: 1px solid %3; border-radius: 4px; background-color: %4; padding: 5px; font-weight: bold; }
        QPushButton:hover { background-color: %5; border-color: %2; }
        QPushButton:pressed { background-color: %2; color: white; border-color: %2; }
        QPushButton:disabled { background-color: transparent; border: 1px solid %1; color: gray; }
        
        QLineEdit, QComboBox { border: 1px solid %3; border-radius: 4px; background-color: %7; padding: 4px; color: palette(text); selection-background-color: %2; }
        QComboBox:hover, QLineEdit:hover { border-color: %2; }
        
        QComboBox::drop-down { subcontrol-origin: padding; subcontrol-position: top right; width: 25px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; background-color: %9; border-left-width: 1px; border-left-color: %3; border-left-style: solid; }
        QComboBox::drop-down:hover { background-color: %10; }
        QComboBox::down-arrow { image: none; width: 0px; height: 0px; border: none; }
        QComboBox QAbstractItemView { border: 1px solid %2; selection-background-color: %2; background-color: %7; outline: none; }
        
        /* Start button (green) / å¯åŠ¨æŒ‰é’® (ç»¿è‰²) */
        QPushButton#btnStart { background-color: #388E3C; color: white; border: 1px solid #2E7D32; }
        QPushButton#btnStart:hover { background-color: #4CAF50; border-color: #43A047; }
        QPushButton#btnStart:pressed { background-color: #1B5E20; border-color: #1B5E20; }
        QPushButton#btnStart:disabled { background-color: transparent; border: 1px solid %1; color: gray; }

        /* Reload button (blue - dynamically set) / é‡è½½æŒ‰é’® (è“è‰² - åŠ¨æ€è®¾ç½®) */
        QPushButton#btnReload { background-color: #0078D4; color: white; border: 1px solid #005A9E; }
        QPushButton#btnReload:hover { background-color: #2B88D8; border-color: #005A9E; }
        QPushButton#btnReload:pressed { background-color: #004578; border-color: #004578; }

        QLabel#lblTokens { color: #E6B422; font-weight: bold; }
        QToolTip { border: 1px solid %2; background-color: %7; color: #E6B422; opacity: 230; padding: 4px; border-radius: 3px; }
    )")
    .arg(qssBtnBorder).arg(highlightColor.name()).arg(qssBtnBorder).arg(qssBtnBg).arg(qssBtnHover)
    .arg(highlightColor.name()).arg(baseColor.name()).arg(textColor.name()).arg(dropDownBg).arg(dropDownHover);
    
    qApp->setStyleSheet(qss);
    m_isDarkTheme = isDark;
}

void MainWindow::setupUi() {
    // Create central widget / åˆ›å»ºä¸­å¿ƒéƒ¨ä»¶
    QWidget *central = new QWidget(this);
    setCentralWidget(central);
    QVBoxLayout *mainLayout = new QVBoxLayout(central);
    mainLayout->setSpacing(10);
    mainLayout->setContentsMargins(10, 10, 10, 10);

    // API Configuration Group / APIé…ç½®åˆ†ç»„
    cfgGroup = new QGroupBox(this);
    QGridLayout *grid = new QGridLayout(cfgGroup);
    grid->setColumnStretch(1, 1);
    grid->setVerticalSpacing(8);
    grid->setHorizontalSpacing(10);

    // Lambda function for creating aligned labels / ç”¨äºåˆ›å»ºå¯¹é½æ ‡ç­¾çš„Lambdaå‡½æ•°
    auto createLabel = [this](QLabel*& memberPtr) {
        memberPtr = new QLabel(this);
        memberPtr->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
        return memberPtr;
    };

    // API Address ComboBox / APIåœ°å€ç»„åˆæ¡†
    apiAddressCombo = new QComboBox(this);
    apiAddressCombo->setEditable(true); 
    apiAddressCombo->setMinimumHeight(28);
    for(const auto& p : PRESETS_DATA) {
        apiAddressCombo->addItem(p.url);
        apiAddressCombo->setItemData(apiAddressCombo->count()-1, p.tips[m_currentLang], Qt::ToolTipRole);
    }
    apiAddressCombo->setCurrentIndex(0);

    grid->addWidget(createLabel(lblApiAddr), 0, 0);
    grid->addWidget(apiAddressCombo, 0, 1);

    // API Key LineEdit / APIå¯†é’¥è¡Œç¼–è¾‘æ¡†
    apiKeyEdit = new QLineEdit(this);
    apiKeyEdit->setEchoMode(QLineEdit::Normal); 
    grid->addWidget(createLabel(lblApiKey), 1, 0);
    grid->addWidget(apiKeyEdit, 1, 1);

    // Model selection with fetch button / æ¨¡å‹é€‰æ‹©å¸¦è·å–æŒ‰é’®
    QWidget *modelContainer = new QWidget(this);
    QHBoxLayout *modelLayout = new QHBoxLayout(modelContainer);
    modelLayout->setContentsMargins(0, 0, 0, 0);
    modelLayout->setSpacing(5);
    
    modelCombo = new QComboBox(this);
    modelCombo->setEditable(true);
    modelCombo->setMinimumHeight(28); 
    
    fetchModelBtn = new QPushButton(this);
    connect(fetchModelBtn, &QPushButton::clicked, this, &MainWindow::onFetchModels);
    
    modelLayout->addWidget(modelCombo, 1); 
    modelLayout->addWidget(fetchModelBtn);
    grid->addWidget(createLabel(lblModel), 2, 0);
    grid->addWidget(modelContainer, 2, 1);

    // Server parameters row / æœåŠ¡å™¨å‚æ•°è¡Œ
    QWidget *paramContainer = new QWidget(this);
    QHBoxLayout *paramLayout = new QHBoxLayout(paramContainer);
    paramLayout->setContentsMargins(0, 0, 0, 0);
    paramLayout->setSpacing(8); 

    lblPort = new QLabel(this);
    portEdit = new QLineEdit(this);
    portEdit->setFixedWidth(55);
    portEdit->setAlignment(Qt::AlignCenter);

    lblThread = new QLabel(this);
    threadSpin = new QSpinBox(this);
    threadSpin->setRange(1, 200);
    threadSpin->setFixedWidth(55);
    threadSpin->setAlignment(Qt::AlignCenter);

    lblTemp = new QLabel(this);
    tempSpin = new QDoubleSpinBox(this);
    tempSpin->setRange(0, 2);
    tempSpin->setSingleStep(0.1);
    tempSpin->setFixedWidth(55);
    tempSpin->setAlignment(Qt::AlignCenter);

    lblCtx = new QLabel(this);
    contextSpin = new QSpinBox(this);
    contextSpin->setRange(0, 20);
    contextSpin->setFixedWidth(55);
    contextSpin->setAlignment(Qt::AlignCenter);

    clearCtxBtn = new QPushButton(this);
    clearCtxBtn->setFixedWidth(50);
    connect(clearCtxBtn, &QPushButton::clicked, this, &MainWindow::onClearContext);

    lblTokens = new QLabel(this);
    lblTokens->setObjectName("lblTokens"); 

    paramLayout->addWidget(lblPort);
    paramLayout->addWidget(portEdit);
    paramLayout->addWidget(lblThread);
    paramLayout->addWidget(threadSpin);
    paramLayout->addWidget(lblTemp);
    paramLayout->addWidget(tempSpin);
    paramLayout->addWidget(lblCtx);
    paramLayout->addWidget(contextSpin);
    paramLayout->addWidget(clearCtxBtn);
    paramLayout->addWidget(lblTokens);
    paramLayout->addStretch();

    grid->addWidget(paramContainer, 3, 0, 1, 2);

    // System Prompt TextEdit / ç³»ç»Ÿæç¤ºè¯æ–‡æœ¬ç¼–è¾‘æ¡†
    systemPromptEdit = new QTextEdit(this);
    systemPromptEdit->setMinimumHeight(100); 

    // System Prompt Label with Lock Checkbox / ç³»ç»Ÿæç¤ºè¯æ ‡ç­¾å¸¦é”å®šå¤é€‰æ¡†
    QWidget *sysLabelContainer = new QWidget(this);
    QVBoxLayout *sysLabelLayout = new QVBoxLayout(sysLabelContainer);
    sysLabelLayout->setContentsMargins(0, 0, 0, 0);
    sysLabelLayout->setSpacing(2); 

    lblSysPrompt = new QLabel(this);
    lblSysPrompt->setAlignment(Qt::AlignRight | Qt::AlignTop);

    chkLockSysPrompt = new QCheckBox(this);
    chkLockSysPrompt->setLayoutDirection(Qt::RightToLeft); 

    QWidget *lockContainer = new QWidget(this);
    QHBoxLayout *lockLayout = new QHBoxLayout(lockContainer);
    lockLayout->setContentsMargins(0,0,0,0);
    lockLayout->addStretch(); 
    lockLayout->addWidget(chkLockSysPrompt);

    sysLabelLayout->addWidget(lblSysPrompt);
    sysLabelLayout->addWidget(lockContainer);
    sysLabelLayout->addStretch(); 

    grid->addWidget(sysLabelContainer, 4, 0);
    grid->addWidget(systemPromptEdit, 4, 1);

    // Pre-Prompt LineEdit / å‰ç½®æ–‡æœ¬è¡Œç¼–è¾‘æ¡†
    prePromptEdit = new QLineEdit(this);
    grid->addWidget(createLabel(lblPrePrompt), 5, 0);
    grid->addWidget(prePromptEdit, 5, 1);

    // ğŸ”¥ Layout Fix for Glossary Path Overflow (from 1.txt) / æœ¯è¯­è¡¨è·¯å¾„æº¢å‡ºçš„å¸ƒå±€ä¿®å¤ï¼ˆæ¥è‡ª1.txtï¼‰
    
    // ğŸ”¥ CAN: ç»„è£…å³ä¾§å†…å®¹å®¹å™¨
    QWidget *glossaryContainer = new QWidget(this);
    QHBoxLayout *glossaryLayout = new QHBoxLayout(glossaryContainer); // å¿…é¡»åˆ›å»ºå¸ƒå±€
    glossaryLayout->setContentsMargins(0, 0, 0, 0);

    chkGlossary = new QCheckBox(this);
    
    glossaryCombo = new QComboBox(this);
    glossaryCombo->setEditable(true); 

    // ğŸ”¥ CAN: å¯ç”¨è‡ªå®šä¹‰ä¸Šä¸‹æ–‡èœå•ç­–ç•¥
    glossaryCombo->setContextMenuPolicy(Qt::CustomContextMenu);
    // è¿æ¥å³é”®ç‚¹å‡»ä¿¡å·
    connect(glossaryCombo, &QComboBox::customContextMenuRequested, this, &MainWindow::onGlossaryContextMenu);

    glossaryCombo->setMinimumHeight(28);
    // CRITICAL: Prevent long paths from stretching window width / å…³é”®ï¼šé˜²æ­¢é•¿è·¯å¾„æ‹‰ä¼¸çª—å£å®½åº¦
    glossaryCombo->setMinimumWidth(0);
    glossaryCombo->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Fixed); 
    
    btnOpenAuto = new QPushButton(STR_BTN_AUTO[m_currentLang], this);
    btnOpenAuto->setFixedWidth(50);
    connect(btnOpenAuto, &QPushButton::clicked, this, &MainWindow::onOpenAutoTranslations);

    btnSelectGlossary = new QPushButton("...", this);
    btnSelectGlossary->setFixedWidth(35);
    connect(btnSelectGlossary, &QPushButton::clicked, this, &MainWindow::onSelectGlossary);

    // ç»„è£…å³ä¾§
    glossaryLayout->addWidget(chkGlossary);
    glossaryLayout->addWidget(glossaryCombo, 1); // Stretch factor 1 / æ‹‰ä¼¸å› å­1
    glossaryLayout->addWidget(btnOpenAuto);
    glossaryLayout->addWidget(btnSelectGlossary);

    // ğŸ”¥ CAN: ç»„è£…å·¦ä¾§æ ‡ç­¾+é”å®šæ¡†
    QWidget *glossaryLabelContainer = new QWidget(this);
    QVBoxLayout *glossaryLabelLayout = new QVBoxLayout(glossaryLabelContainer);
    glossaryLabelLayout->setContentsMargins(0, 0, 0, 0);
    glossaryLabelLayout->setSpacing(2); 

    lblGlossary = new QLabel(this);
    lblGlossary->setAlignment(Qt::AlignRight | Qt::AlignTop);

    chkLockGlossary = new QCheckBox(this);
    chkLockGlossary->setLayoutDirection(Qt::RightToLeft); 

    QWidget *gLockContainer = new QWidget(this);
    QHBoxLayout *gLockLayout = new QHBoxLayout(gLockContainer);
    gLockLayout->setContentsMargins(0, 0, 0, 0);
    gLockLayout->addStretch(); 
    gLockLayout->addWidget(chkLockGlossary);

    glossaryLabelLayout->addWidget(lblGlossary);
    glossaryLabelLayout->addWidget(gLockContainer);
    glossaryLabelLayout->addStretch(); 
    
    grid->addWidget(glossaryLabelContainer, 6, 0); // æ”¾åœ¨ç¬¬6è¡Œç¬¬0åˆ—
    grid->addWidget(glossaryContainer, 6, 1); // æ”¾åœ¨ç¬¬6è¡Œç¬¬1åˆ—

    mainLayout->addWidget(cfgGroup);

    // Control buttons grid / æ§åˆ¶æŒ‰é’®ç½‘æ ¼
    QGridLayout *btnGridLayout = new QGridLayout();
    btnGridLayout->setSpacing(10);
    
    auto createBtn = [this] (QPushButton*& btnPtr) {
        btnPtr = new QPushButton(this);
        btnPtr->setMinimumHeight(32);
        btnPtr->setCursor(Qt::PointingHandCursor);
        return btnPtr;
    };

    btnGridLayout->addWidget(createBtn(startBtn), 0, 0);
    startBtn->setObjectName("btnStart"); 

    btnGridLayout->addWidget(createBtn(stopBtn), 0, 1);
    stopBtn->setEnabled(false);
    
    hudBtn = new QPushButton(this);
    hudBtn->setMinimumHeight(32);
    hudBtn->setCursor(Qt::PointingHandCursor);
    hudBtn->setEnabled(false); 
    connect(hudBtn, &QPushButton::clicked, this, &MainWindow::switchToHud);
    btnGridLayout->addWidget(hudBtn, 0, 2);

    btnGridLayout->addWidget(createBtn(testBtn), 1, 0);
    btnGridLayout->addWidget(createBtn(exportBtn), 1, 1);
    btnGridLayout->addWidget(createBtn(loadBtn), 1, 2);

    btnGridLayout->addWidget(createBtn(saveBtn), 2, 0);
    btnGridLayout->addWidget(createBtn(themeBtn), 2, 1);
    btnGridLayout->addWidget(createBtn(langBtn), 2, 2);

    // Connect button signals / è¿æ¥æŒ‰é’®ä¿¡å·
    connect(themeBtn, &QPushButton::clicked, this, &MainWindow::toggleTheme);
    connect(langBtn, &QPushButton::clicked, this, &MainWindow::toggleLanguage);
    connect(startBtn, &QPushButton::clicked, this, &MainWindow::onStartClicked);
    connect(stopBtn, &QPushButton::clicked, this, &MainWindow::onStopClicked);
    connect(testBtn, &QPushButton::clicked, this, &MainWindow::onTestConfig);
    connect(loadBtn, &QPushButton::clicked, this, &MainWindow::onLoadConfig);
    connect(saveBtn, &QPushButton::clicked, this, &MainWindow::onSaveConfig);
    connect(exportBtn, &QPushButton::clicked, this, &MainWindow::onExportLog);

    mainLayout->addLayout(btnGridLayout);

    // Log area / æ—¥å¿—åŒºåŸŸ
    logGroup = new QGroupBox(this);
    QVBoxLayout *logLayout = new QVBoxLayout(logGroup);
    logLayout->setContentsMargins(10, 20, 10, 10);
    logArea = new QTextEdit(this);
    logArea->setReadOnly(true);
    logArea->setMinimumHeight(150); 
    logArea->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(logArea, &QTextEdit::customContextMenuRequested, this, &MainWindow::onLogContextMenu);
    logLayout->addWidget(logArea);
    mainLayout->addWidget(logGroup);

    // Create loading overlay for fetch button / ä¸ºè·å–æŒ‰é’®åˆ›å»ºåŠ è½½è¦†ç›–å±‚
    fetchLoadingOverlay = new LoadingOverlay(fetchModelBtn);

    // Connect glossary combo box signal / è¿æ¥æœ¯è¯­è¡¨ç»„åˆæ¡†ä¿¡å·
    connect(glossaryCombo, &QComboBox::activated, this, &MainWindow::onGlossaryChanged);

    connect(glossaryCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), [this](int index){
    Q_UNUSED(index);
    // ä½¿ç”¨ QTimer::singleShot æ˜¯ä¸ºäº†ç¡®ä¿åœ¨ Qt å®Œæˆå†…éƒ¨æ–‡æœ¬æ¸²æŸ“åå†æ‰§è¡Œå…‰æ ‡ç§»åŠ¨
    QTimer::singleShot(0, [this](){
        if (glossaryCombo->lineEdit()) {
            glossaryCombo->lineEdit()->setCursorPosition(0);
        }
    });
    });

}

void MainWindow::onLogContextMenu(const QPoint &pos) {
    // Create standard context menu for text edit / ä¸ºæ–‡æœ¬ç¼–è¾‘æ¡†åˆ›å»ºæ ‡å‡†ä¸Šä¸‹æ–‡èœå•
    QMenu *menu = logArea->createStandardContextMenu();
    menu->addSeparator();
    
    // Add "Clear Log" action / æ·»åŠ "æ¸…ç©ºæ—¥å¿—"æ“ä½œ
    QAction *clearAction = menu->addAction(STR_CLEAR_LOG[m_currentLang]);
    connect(clearAction, &QAction::triggered, logArea, &QTextEdit::clear);
    
    // Show menu at cursor position / åœ¨å…‰æ ‡ä½ç½®æ˜¾ç¤ºèœå•
    menu->exec(logArea->mapToGlobal(pos));
    delete menu;
}

void MainWindow::loadConfigToUi() {
    // Load configuration from file / ä»æ–‡ä»¶åŠ è½½é…ç½® (Manager ä¾ç„¶è´Ÿè´£åŸºç¡€æ•°æ®)
    AppConfig cfg = ConfigManager::loadConfig();
    
    // 1. ğŸ”¥ CAN: ç‹¬ç«‹æ¢å¤é”å®šæ¡†çŠ¶æ€ (ä¸ç»è¿‡ç»“æ„ä½“)
    // ç›´æ¥ä» config.ini è¯»å–é”å®šçŠ¶æ€ã€‚å¦‚æœæ²¡æœ‰è¯¥å€¼ï¼Œé»˜è®¤ä¸º falseã€‚
    QSettings sess("config.ini", QSettings::IniFormat);
    bool isLocked = sess.value("Settings/lock_glossary_path", false).toBool();
    chkLockGlossary->setChecked(isLocked);

    // 2. å¡«å……å¸¸è§„ UI å…ƒç´ 
    apiAddressCombo->setCurrentText(cfg.api_address);
    apiKeyEdit->setText(cfg.api_key);
    modelCombo->setCurrentText(cfg.model_name);
    portEdit->setText(QString::number(cfg.port));
    tempSpin->setValue(cfg.temperature);
    contextSpin->setValue(cfg.context_num);
    threadSpin->setValue(cfg.max_threads);
    systemPromptEdit->setText(cfg.system_prompt);
    prePromptEdit->setText(cfg.pre_prompt);
    chkGlossary->setChecked(cfg.enable_glossary);

    // 3. åŠ è½½æœ¯è¯­è¡¨å†å²è®°å½•
    glossaryCombo->clear();
    if (!cfg.glossary_history.isEmpty()) {
        glossaryCombo->addItems(cfg.glossary_history);
    }
    
    // 4. è®¾ç½®å½“å‰æœ¯è¯­è¡¨è·¯å¾„
    if (!cfg.glossary_path.isEmpty()) {
        int index = glossaryCombo->findText(cfg.glossary_path);
        if (index != -1) glossaryCombo->setCurrentIndex(index);
        else addToGlossaryHistory(cfg.glossary_path);
    }
    
    // -------------------------------------------------------------
    // âœ… å¯åŠ¨æ—¶å¼ºåˆ¶å…‰æ ‡èšç„¦åˆ°è·¯å¾„å¼€å¤´ (Focus Forward)
    // -------------------------------------------------------------
    if (glossaryCombo->lineEdit()) {
        glossaryCombo->lineEdit()->setCursorPosition(0);
    }
    
    // è®¾ç½®è¯­è¨€
    m_currentLang = cfg.language;
}

AppConfig MainWindow::getUiConfig() {
    // Collect current UI state into config object / å°†å½“å‰UIçŠ¶æ€æ”¶é›†åˆ°é…ç½®å¯¹è±¡ä¸­
    AppConfig cfg;
    cfg.api_address = apiAddressCombo->currentText();
    cfg.api_key = apiKeyEdit->text();
    cfg.model_name = modelCombo->currentText();
    cfg.port = portEdit->text().toInt();
    cfg.temperature = tempSpin->value();
    cfg.context_num = contextSpin->value();
    cfg.max_threads = threadSpin->value();
    cfg.system_prompt = systemPromptEdit->toPlainText();
    cfg.pre_prompt = prePromptEdit->text();
    cfg.enable_glossary = chkGlossary->isChecked();
    
    // ğŸ”¥ CAN: å‰¥ç¦» lock_glossary_path (ä¸å†èµ‹å€¼ç»™ cfg)
    // è¿™é‡Œåªæ”¶é›†ç»“æ„ä½“å®šä¹‰çš„å­—æ®µã€‚é”å®šæ¡†çš„çŠ¶æ€æˆ‘ä»¬ä¼šåœ¨ closeEvent é‡Œå•ç‹¬å­˜ã€‚
    
    cfg.glossary_path = glossaryCombo->currentText();
    
    // ä¿å­˜æœ¯è¯­è¡¨å†å²è®°å½•
    QStringList history;
    for(int i = 0; i < glossaryCombo->count(); ++i) {
        history << glossaryCombo->itemText(i);
    }
    cfg.glossary_history = history;
    cfg.language = m_currentLang;
    
    return cfg;
}

void MainWindow::toggleControls(bool running) {
    m_isServerRunning = running;

    // --- âœ… å…³é”®ä¿®æ”¹ï¼šè§£é™¤é”å®šä»¥æ”¯æŒçƒ­é‡è½½ ---
    // å…è®¸åœ¨è¿è¡Œæ—¶ä¿®æ”¹ API åœ°å€ã€å¯†é’¥ã€æ¨¡å‹å’Œå‚æ•°
    apiAddressCombo->setEnabled(true); 
    apiKeyEdit->setEnabled(true);
    modelCombo->setEnabled(true);      // ç¡®ä¿æ¨¡å‹é€‰æ‹©æ¡†ä¹Ÿä¿æŒå¼€å¯
    tempSpin->setEnabled(true);        // å…è®¸è¿è¡Œæ—¶è°ƒæ•´æ¸©åº¦
    contextSpin->setEnabled(true);     // å…è®¸è¿è¡Œæ—¶è°ƒæ•´ä¸Šä¸‹æ–‡è®°å¿†

    // åªæœ‰ç«¯å£å’Œçº¿ç¨‹æ•°å»ºè®®ä¿æŒé”å®š (ä¿®æ”¹è¿™äº›é€šå¸¸éœ€è¦å½»åº•é‡å¯ Socket æˆ–çº¿ç¨‹æ± )
    portEdit->setEnabled(!running);
    threadSpin->setEnabled(!running);
    
    // 2. æœ¯è¯­è¡¨é€»è¾‘ (UNFROZEN: ä¿æŒç¬¬ä¸€ä»½ä»£ç çš„çµæ´»æ€§)
    glossaryCombo->setEnabled(true); 

    // 3. ğŸ”¥ HUD æŒ‰é’®ä¿®å¤: åªåœ¨å¯åŠ¨æœåŠ¡åæ‰å¯ä½¿ç”¨
    hudBtn->setEnabled(running);

    // 4. çœç•¥å·æŒ‰é’®äº¤äº’ (ä¿ç•™ç¬¬ä¸€ä»½ä»£ç çš„é«˜çº§è§†è§‰åé¦ˆ)
    QString baseDescription = (m_currentLang == 0) 
        ? "Select glossary files (.txt)" 
        : "é€‰æ‹©æœ¯è¯­è¡¨æ–‡ä»¶ (.txt)";

    if (running) {
        // è¿½åŠ è¿è¡ŒçŠ¶æ€æç¤º
        QString runningNotice = (m_currentLang == 0)
            ? "\n\n(â„¹ï¸ Server is running: You can still click to change paths \n\n You can right-click on the glossary path to open the clean menu)"
            : "\n\n(â„¹ï¸ æœåŠ¡è¿è¡Œä¸­ï¼šæ‚¨ä»å¯ç‚¹å‡»æ­¤å¤„æ›´æ”¹è·¯å¾„ \n\n æ‚¨å¯ä»¥åœ¨æœ¯è¯­è¡¨è·¯å¾„ä¸Šå³é”®ä»¥æ‰“å¼€æ¸…ç†èœå•)";
        btnSelectGlossary->setToolTip(baseDescription + runningNotice);

        // æ ·å¼ï¼šå¹³æ—¶ä½è°ƒï¼Œæ‚¬æµ®ç‚¹äº®
        btnSelectGlossary->setStyleSheet(
            "QPushButton { "
            "  color: rgba(200, 200, 200, 120); " 
            "  border: 1px solid rgba(150, 150, 150, 60); "
            "  background-color: transparent; "
            "} "
            "QPushButton:hover { "
            "  color: #ffffff; "
            "  background-color: #3d8af7; "
            "  border: 1px solid #3d8af7; "
            "}"
        );
    } else {
        btnSelectGlossary->setToolTip(baseDescription);
        btnSelectGlossary->setStyleSheet(""); 
    }

    // 5. åŠŸèƒ½æ€§æŒ‰é’®ä¿æŒå¯ç”¨
    themeBtn->setEnabled(true);
    langBtn->setEnabled(true);
    clearCtxBtn->setEnabled(true); // è¿è¡Œæ—¶å…è®¸æ‰‹åŠ¨æ¸…ç©ºè®°å¿†

    // 6. æœåŠ¡æ§åˆ¶æŒ‰é’®åˆ‡æ¢ä¸æ ·å¼åˆ·æ–°
    if (running) {
        startBtn->setText(m_currentLang == 0 ? "Reload Config" : "é‡è½½é…ç½®");
        startBtn->setObjectName("btnReload"); // åº”ç”¨çƒ­é‡è½½è“è‰²æ ·å¼
    } else {
        startBtn->setText(m_currentLang == 0 ? "Start Server" : "å¯åŠ¨æœåŠ¡");
        startBtn->setObjectName("btnStart");  // æ¢å¤å¯åŠ¨ç»¿è‰²æ ·å¼
    }
    stopBtn->setEnabled(running);

    // ğŸ”¥ å¿…é¡»æ‰§è¡Œæ ·å¼é‡åˆ·ï¼Œå¦åˆ™ ObjectName çš„æ”¹å˜ä¸ä¼šç«‹å³è§¦å‘ CSS é¢œè‰²å˜åŒ–
    startBtn->style()->unpolish(startBtn);
    startBtn->style()->polish(startBtn);
}

// ğŸ”¥ CRITICAL: Robust Hot Reload Logic from 1.txt / å…³é”®ï¼šæ¥è‡ª1.txtçš„é²æ£’çƒ­é‡è½½é€»è¾‘
void MainWindow::onStartClicked() {
    AppConfig newCfg = getUiConfig();

    if (m_isServerRunning) {
        // === ğŸ”¥ å®Œæ•´çƒ­é‡è½½é€»è¾‘ (Hot Reload) ===
        AppConfig oldCfg = server->getConfig();
        
        // 1. æ¨¡å‹åˆ‡æ¢æ£€æµ‹è®°å½•
        if (oldCfg.model_name != newCfg.model_name) {
            onLogMessage(QString(LOG_MODEL_SWITCH[m_currentLang])
                            .arg(oldCfg.model_name)
                            .arg(newCfg.model_name));
        } else {
            onLogMessage(QString(LOG_MODEL_SAME[m_currentLang]).arg(newCfg.model_name));
        }

        // 2. æ›´æ–°æœåŠ¡å™¨é…ç½®
        server->updateConfig(newCfg);

        

        onLogMessage(LOG_RELOADED[m_currentLang]);
        
        // 3. è§†è§‰åé¦ˆï¼šæŒ‰é’®é—ªçƒåŠ¨ç”» (ä»åŸå§‹ç‰ˆæœ¬æ¢å¤)
        QPropertyAnimation *anim = new QPropertyAnimation(startBtn, "windowOpacity");
        anim->setDuration(150);
        anim->setStartValue(0.5);
        anim->setEndValue(1.0);
        anim->start(QAbstractAnimation::DeleteWhenStopped);

        // 4. è‡ªåŠ¨æµ‹è¯•è¿é€šæ€§
        onLogMessage(LOG_AUTO_TESTING[m_currentLang]);
        onTestConfig();

    } else {
        // === ğŸš€ æ­£å¸¸å¯åŠ¨é€»è¾‘ (Start) ===
        server->updateConfig(newCfg);
        server->startServer();
        toggleControls(true); 
    }
}

void MainWindow::onStopClicked() {
    server->stopServer();
    toggleControls(false); 
}

void MainWindow::onLogMessage(QString msg) {
    // Append message to log area / å°†æ¶ˆæ¯è¿½åŠ åˆ°æ—¥å¿—åŒºåŸŸ
    logArea->append(msg);
    
    // Limit log size to prevent memory issues / é™åˆ¶æ—¥å¿—å¤§å°ä»¥é˜²æ­¢å†…å­˜é—®é¢˜
    const int MAX_LOG_LINES = 2000;
    if (logArea->document()->blockCount() > MAX_LOG_LINES) {
        QTextCursor cursor(logArea->document());
        cursor.movePosition(QTextCursor::Start);
        for(int i = 0; i < 500; ++i) {
            cursor.movePosition(QTextCursor::NextBlock, QTextCursor::KeepAnchor);
        }
        cursor.removeSelectedText();
    }
}

void MainWindow::onSaveConfig() {
    // Open save file dialog / æ‰“å¼€ä¿å­˜æ–‡ä»¶å¯¹è¯æ¡†
    QString fileName = QFileDialog::getSaveFileName(this, STR_SAVE[m_currentLang], "config.ini", "Config Files (*.ini)");
    if (!fileName.isEmpty()) {
        ConfigManager::saveConfig(getUiConfig(), fileName);
        logArea->append(QString(LOG_CFG_SAVED[m_currentLang]) + fileName);
    }
}

void MainWindow::onLoadConfig() {
    // Open load file dialog / æ‰“å¼€åŠ è½½æ–‡ä»¶å¯¹è¯æ¡†
    QString fileName = QFileDialog::getOpenFileName(this, STR_LOAD[m_currentLang], "", "Config Files (*.ini)");
    if (fileName.isEmpty()) return;

    // 1. ä»æ–‡ä»¶åŠ è½½é…ç½®ï¼ˆManager ä¾ç„¶åªè´Ÿè´£å®ƒèƒ½è¯»åˆ°çš„åŸºç¡€æ•°æ®ï¼‰
    AppConfig cfg = ConfigManager::loadConfig(fileName);
    
    // 2. æ›´æ–°åŸºç¡€ UI å…ƒç´ 
    apiAddressCombo->setCurrentText(cfg.api_address);
    apiKeyEdit->setText(cfg.api_key);
    modelCombo->setCurrentText(cfg.model_name);
    portEdit->setText(QString::number(cfg.port));
    tempSpin->setValue(cfg.temperature);
    contextSpin->setValue(cfg.context_num);
    threadSpin->setValue(cfg.max_threads);
    
    // ç³»ç»Ÿæç¤ºè¯é”å®šé€»è¾‘
    if (!chkLockSysPrompt->isChecked()) {
        systemPromptEdit->setText(cfg.system_prompt);
    }

    prePromptEdit->setText(cfg.pre_prompt);
    chkGlossary->setChecked(cfg.enable_glossary);

    // -------------------------------------------------------------
    // ğŸ”¥ CAN: å†»ç»“æ–¹æ³•å®ç° (The Freeze Method)
    // -------------------------------------------------------------
    // åªæœ‰åœ¨å½“å‰ã€é”å®šæ¡†æœªå‹¾é€‰ã€‘çš„æƒ…å†µä¸‹ï¼Œæ‰å…è®¸ä»é…ç½®æ–‡ä»¶æ›´æ–°æœ¯è¯­è¡¨ç¯å¢ƒã€‚
    // å¦‚æœå·²é”å®šï¼Œä¸‹é¢æ•´ä¸ªä»£ç å—å°†è¢«è·³è¿‡ï¼Œå®ç°æœ¯è¯­è¡¨è·¯å¾„å’Œå†å²è®°å½•çš„â€œç¬é—´å†»ç»“â€ã€‚
    if (!chkLockGlossary->isChecked()) {
        // A. æ›´æ–°å†å²è®°å½•åˆ—è¡¨
        if (!cfg.glossary_history.isEmpty()) {
            glossaryCombo->clear();
            glossaryCombo->addItems(cfg.glossary_history);
        }
        
        // B. æ›´æ–°å½“å‰æ˜¾ç¤ºçš„è·¯å¾„
        if (!cfg.glossary_path.isEmpty()) {
            glossaryCombo->setCurrentText(cfg.glossary_path);
        }

        // æ³¨æ„ï¼šè¿™é‡Œä¸å†ä» cfg è¯»å– lock_glossary_pathï¼Œ
        // å› ä¸ºæˆ‘ä»¬å·²ç»è§£è€¦äº†å®ƒã€‚é”å®šçŠ¶æ€ç”± UI å½“å‰çŠ¶æ€å†³å®šã€‚
    }

    // -------------------------------------------------------------
    // âœ… ä¿æŒå¼ºåˆ¶ç„¦ç‚¹å‰ç§»
    // ç¡®ä¿æ— è®ºæ˜¯å¦æ›´æ–°äº†è·¯å¾„ï¼Œæ˜¾ç¤ºçš„ä¸€ç›´æ˜¯è·¯å¾„çš„å¼€å¤´
    // -------------------------------------------------------------
    if (glossaryCombo->lineEdit()) {
        glossaryCombo->lineEdit()->setCursorPosition(0);
    }
    
    logArea->append(QString(LOG_CFG_LOADED[m_currentLang]) + fileName);
}

void MainWindow::onExportLog() {
    // Export log to file / å°†æ—¥å¿—å¯¼å‡ºåˆ°æ–‡ä»¶
    QString fileName = "run_log.txt";
    QFile file(fileName);
    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream out(&file);
        #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
            out.setEncoding(QStringConverter::Utf8);
        #else
            out.setCodec("UTF-8");
        #endif
        out << logArea->toPlainText();
        logArea->append(LOG_EXPORTED[m_currentLang]);
    }
}

void MainWindow::onFetchModels() {
    // Get API address from combo box / ä»ç»„åˆæ¡†è·å–APIåœ°å€
    QString url = apiAddressCombo->currentText();
    if(url.isEmpty()) return;
    if(url.endsWith("/")) url.chop(1);
    
    // Show loading overlay / æ˜¾ç¤ºåŠ è½½è¦†ç›–å±‚
    if(fetchLoadingOverlay) {
        fetchLoadingOverlay->setGeometry(fetchModelBtn->rect());
        fetchLoadingOverlay->raise();
        fetchLoadingOverlay->start();
    }

    logArea->append(m_currentLang == 1 ? "ğŸ” æ­£åœ¨è·å–æ¨¡å‹åˆ—è¡¨..." : "ğŸ” Fetching models...");
    
    // Create network request / åˆ›å»ºç½‘ç»œè¯·æ±‚
    QNetworkAccessManager *mgr = new QNetworkAccessManager(this);
    QNetworkRequest req(url + "/models");
    req.setTransferTimeout(10000); // 10 second timeout / 10ç§’è¶…æ—¶
    
    // Get first API key from comma-separated list / ä»é€—å·åˆ†éš”çš„åˆ—è¡¨ä¸­è·å–ç¬¬ä¸€ä¸ªAPIå¯†é’¥
    QString key = apiKeyEdit->text().split(',')[0].trimmed();
    req.setRawHeader("Authorization", ("Bearer " + key).toUtf8());
    
    QNetworkReply *reply = mgr->get(req);
    connect(reply, &QNetworkReply::finished, [this, reply, mgr](){
        // Hide loading overlay / éšè—åŠ è½½è¦†ç›–å±‚
        if(fetchLoadingOverlay) fetchLoadingOverlay->stop();

        if(reply->error() == QNetworkReply::NoError) {
            try {
                // Parse JSON response / è§£æJSONå“åº”
                auto jsonDoc = nlohmann::json::parse(reply->readAll().toStdString());
                modelCombo->clear();
                int count = 0;
                for(const auto& item : jsonDoc["data"]) {
                    modelCombo->addItem(QString::fromStdString(item["id"]));
                    count++;
                }
                logArea->append(m_currentLang == 1 ? QString("âœ… è·å–æˆåŠŸï¼å…±å‘ç° %1 ä¸ªå¯ç”¨æ¨¡å‹ã€‚").arg(count) 
                                                 : QString("âœ… Success! Found %1 available models.").arg(count));
                modelCombo->setFocus();
            } catch(...) {
                logArea->append("âŒ " + QString(LOG_PARSE_ERR[m_currentLang]));
            }
        } else {
            // Handle error / å¤„ç†é”™è¯¯
            int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
            if (reply->error() == QNetworkReply::TimeoutError) statusCode = 999;
            logArea->append("âŒ " + getFriendlyErrorMessage(statusCode, m_currentLang));
        }
        reply->deleteLater();
        mgr->deleteLater();
    });
}

void MainWindow::onTestConfig() {
    logArea->append(LOG_TEST_START[m_currentLang]);
    
    // Get API keys from comma-separated list / ä»é€—å·åˆ†éš”çš„åˆ—è¡¨ä¸­è·å–APIå¯†é’¥
    QStringList keys = apiKeyEdit->text().split(',', Qt::SkipEmptyParts);
    if (keys.isEmpty()) {
        logArea->append(LOG_NO_KEY[m_currentLang]);
        return;
    }
    
    testBtn->setEnabled(false);
    
    // Prepare API endpoint URL / å‡†å¤‡APIç«¯ç‚¹URL
    QString url = apiAddressCombo->currentText();
    if(url.endsWith("/")) url.chop(1);
    url += "/chat/completions";
    QString model = modelCombo->currentText();

    // Shared counters for tracking completion / ç”¨äºè·Ÿè¸ªå®Œæˆçš„å…±äº«è®¡æ•°å™¨
    auto finishedCount = std::make_shared<int>(0);
    auto successCount = std::make_shared<int>(0);
    int total = keys.size();

    // Test each API key / æµ‹è¯•æ¯ä¸ªAPIå¯†é’¥
    for (int i = 0; i < total; ++i) {
        QString key = keys[i].trimmed();
        // ğŸ’¡ Restore previous masking logic: (... + last 8 digits) / è¿˜åŸä¹‹å‰çš„è„±æ•é€»è¾‘ï¼š(... + å8ä½)
        QString keyMasked = (key.length() > 8) ? ("..." + key.right(8)) : key;
        
        QNetworkAccessManager *mgr = new QNetworkAccessManager(this);
        QNetworkRequest req(url);
        req.setTransferTimeout(10000); // 10 second timeout / 10ç§’è¶…æ—¶
        
        req.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
        req.setRawHeader("Authorization", ("Bearer " + key).toUtf8());
        
        // Prepare test request JSON / å‡†å¤‡æµ‹è¯•è¯·æ±‚JSON
        nlohmann::json j;
        j["model"] = model.toStdString();
        j["messages"] = nlohmann::json::array({{{"role", "user"}, {"content", "Hi"}}});
        j["max_tokens"] = 5;
        
        QNetworkReply *reply = mgr->post(req, QByteArray::fromStdString(j.dump()));
        
        // ğŸ’¡ Capture [=] to ensure correct copy of i / æ•è· [=] ä»¥ç¡®ä¿ i å‰¯æœ¬æ­£ç¡®
        connect(reply, &QNetworkReply::finished, [this, reply, mgr, keyMasked, i, finishedCount, successCount, total](){
            (*finishedCount)++;
            bool isOk = (reply->error() == QNetworkReply::NoError);
            if(isOk) (*successCount)++;

            int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
            if (reply->error() == QNetworkReply::TimeoutError) statusCode = 999;

            // ğŸ’¡ Construct classic output line / æ„é€ ç»å…¸è¾“å‡ºè¡Œ
            QString icon = isOk ? "âœ…" : "âŒ";
            QString status = isOk ? (m_currentLang == 1 ? "æµ‹è¯•é€šè¿‡" : "PASS") 
                                 : getFriendlyErrorMessage(statusCode, m_currentLang);
            
            // Format: âœ… Key-1 (...SEPO): æµ‹è¯•é€šè¿‡ / æ ¼å¼ï¼šâœ… Key-1 (...SEPO): æµ‹è¯•é€šè¿‡
            logArea->append(QString("%1 Key-%2 (%3): %4")
                            .arg(icon).arg(i + 1).arg(keyMasked).arg(status));

            // ğŸ’¡ Summary prompt / æ±‡æ€»æç¤º
            if (*finishedCount == total) {
                testBtn->setEnabled(true);
                logArea->append("----------------------------------");
                QString summary = (m_currentLang == 1) 
                    ? QString("ğŸ“Š æµ‹è¯•ç»“æŸï¼æˆåŠŸ: %1, å¤±è´¥: %2").arg(*successCount).arg(total - *successCount)
                    : QString("ğŸ“Š Finished! Success: %1, Failed: %2").arg(*successCount).arg(total - *successCount);
                logArea->append("<b>" + summary + "</b>");
            }

            reply->deleteLater();
            mgr->deleteLater();
        });
    }
}

void MainWindow::updateTokenDisplay(long long total, long long prompt, long long completion) {
    // 1. Store values in widget properties (Qt dynamic properties, no need to define variables in .h)
    // 1. å°†æ•°å€¼å­˜å…¥æ§ä»¶å±æ€§ä¸­ (Qt åŠ¨æ€å±æ€§ï¼Œä¸éœ€è¦åœ¨ .h ä¸­å®šä¹‰å˜é‡)
    lblTokens->setProperty("total", total);
    lblTokens->setProperty("prompt", prompt);
    lblTokens->setProperty("completion", completion);

    // 2. Update main interface text / 2. æ›´æ–°ä¸»ç•Œé¢æ–‡å­—
    lblTokens->setText(QString("%1 %2").arg(STR_TOKENS[m_currentLang]).arg(total));

    // 3. Combine tooltip: description + detailed data (fix "splitting" issue) / 3. ç»„åˆæç¤ºï¼šè¯´æ˜æ–‡å­— + è¯¦ç»†æ•°æ® (ä¿®æ­£"åˆ†è£‚"é—®é¢˜)
    QString strPrompt = (m_currentLang == 1) ? "è¾“å…¥ (Prompt):" : "Input (Prompt):";
    QString strCompletion = (m_currentLang == 1) ? "è¾“å‡º (Completion):" : "Output (Completion):";

    QString fullTip = QString("<b>%1</b><br><br>%2 %3<br>%4 %5")
                        .arg(TIP_TOKENS[m_currentLang])
                        .arg(strPrompt).arg(prompt)
                        .arg(strCompletion).arg(completion);

    lblTokens->setToolTip(fullTip);
}

void MainWindow::onClearContext() {
    server->clearAllContexts();
}

void MainWindow::switchToHud() {
    if (!server) return;
    
    // Fade out animation / æ·¡å‡ºåŠ¨ç”»
    QPropertyAnimation *anim = new QPropertyAnimation(this, "windowOpacity");
    anim->setDuration(300);
    anim->setStartValue(1.0);
    anim->setEndValue(0.0);
    
    connect(anim, &QPropertyAnimation::finished, [this](){
        this->hide();
        // Position HUD window near main window / å°†HUDçª—å£å®šä½åœ¨ä¸»çª—å£é™„è¿‘
        m_hudWindow->move(this->geometry().topRight() - QPoint(280, -20)); 
        m_hudWindow->show();
        m_hudWindow->setStatus(false);
        m_hudWindow->updateTokens(m_tokenManager->getTotal());
    });
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}

void MainWindow::restoreFromHud() {
    m_hudWindow->hide();
    this->setWindowOpacity(0.0);
    this->show();
    
    // Fade in animation / æ·¡å…¥åŠ¨ç”»
    QPropertyAnimation *anim = new QPropertyAnimation(this, "windowOpacity");
    anim->setDuration(300);
    anim->setStartValue(0.0);
    anim->setEndValue(1.0);
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}

void MainWindow::onServerWorkStarted() {
    if (m_hudWindow && m_hudWindow->isVisible()) {
        m_hudWindow->setStatus(true);
    }
}

void MainWindow::onServerWorkFinished(bool success) {
    if (m_hudWindow && m_hudWindow->isVisible()) {
        m_hudWindow->setStatus(false, !success); 
    }
}

// Glossary Mangagement Context Menu Handler / æœ¯è¯­è¡¨ç®¡ç†å³é”®èœå•å¤„ç†å™¨

void MainWindow::onGlossaryContextMenu(const QPoint &pos) {
    int lang = m_currentLang;
    
    // åˆ›å»ºå³é”®èœå•
    QMenu menu(this);
    
    // åŠ¨ä½œ 1ï¼šåˆ é™¤å½“å‰é€‰ä¸­çš„è¿™ä¸€æ¡
    QAction *removeAction = menu.addAction(STR_REMOVE_PATH[lang]);
    // åŠ¨ä½œ 2ï¼šæ¸…ç©ºå…¨éƒ¨
    QAction *clearAction = menu.addAction(STR_CLEAR_HISTORY[lang]);
    
    // å¦‚æœå½“å‰æ˜¯ç©ºçš„ï¼Œç¦ç”¨åˆ é™¤åŠ¨ä½œ
    if (glossaryCombo->currentText().isEmpty()) {
        removeAction->setEnabled(false);
    }

    // åœ¨é¼ æ ‡ä½ç½®å¼¹å‡ºèœå•
    QAction *selectedAction = menu.exec(glossaryCombo->mapToGlobal(pos));
    
    if (selectedAction == removeAction) {
        // --- é€»è¾‘ï¼šåˆ é™¤å½“å‰é¡¹ ---
        int index = glossaryCombo->currentIndex();
        if (index != -1) {
            glossaryCombo->removeItem(index);
            logArea->append(lang == 1 ? "ğŸ§½ å·²ä»å†å²è®°å½•ä¸­ç§»é™¤è¯¥è·¯å¾„ã€‚" : "ğŸ§½ Removed current path from history.");
        } else {
            // å¦‚æœæ˜¯ç”¨æˆ·åˆšè¾“å…¥ä½†æ²¡è¿›åˆ—è¡¨çš„æ–‡å­—ï¼Œç›´æ¥æ¸…ç©ºè¾“å…¥æ¡†
            glossaryCombo->setEditText("");
        }
    } else if (selectedAction == clearAction) {
        // --- é€»è¾‘ï¼šæ¸…ç©ºå…¨éƒ¨ ---
        glossaryCombo->clear();
        logArea->append(lang == 1 ? "ğŸ—‘ï¸ æœ¯è¯­è¡¨å†å²è®°å½•å·²æ¸…ç©ºã€‚" : "ğŸ—‘ï¸ Glossary history cleared.");
    }
}

// ğŸ› ï¸ Human-friendly error message mapping / äººæ€§åŒ–é”™è¯¯ä¿¡æ¯æ˜ å°„
// Added at the end of MainWindow.cpp / åœ¨ MainWindow.cpp çš„æœ«å°¾æ·»åŠ ï¼š

QString MainWindow::getFriendlyErrorMessage(int code, int lang) {
    if (lang == 1) { // ç®€ä½“ä¸­æ–‡
        switch (code) {
            case 0:   return "ç½‘ç»œè¿æ¥è¶…æ—¶: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ API åœ°å€æˆ–ç½‘ç»œä»£ç†ã€‚";
            case 400: return "è¯·æ±‚æ ¼å¼é”™è¯¯ (400): è¯·æ£€æŸ¥å‚æ•°è®¾ç½®æ˜¯å¦ç¬¦åˆè¯¥æ¨¡å‹è¦æ±‚ã€‚";
            case 401: return "èº«ä»½éªŒè¯å¤±è´¥ (401): API Key æˆ–æ˜¯ APIåœ°å€ å¡«å†™é”™è¯¯ã€å·²è¿‡æœŸæˆ–å·²è¢«å°ç¦ã€‚";
            case 402: return "é¢åº¦ä¸è¶³ (402): è´¦æˆ·ä½™é¢å·²è€—å°½ï¼Œè¯·å‰å¾€å®˜ç½‘å……å€¼ã€‚";
            case 403: return "æ‹’ç»è®¿é—® (403): æƒé™ä¸è¶³ï¼Œæˆ–è€…è¯¥ Key ä¸æ”¯æŒè®¿é—®æ‰€é€‰æ¨¡å‹ã€‚";
            case 404: return "åœ°å€é”™è¯¯ (404): API åœ°å€æˆ–è·¯å¾„é”™è¯¯ï¼Œè¯·æ£€æŸ¥æœ«å°¾æ˜¯å¦å¤š/å°‘äº† /v1ã€‚";
            case 429: return "é¢‘ç‡é™åˆ¶/é¢åº¦ç”¨å°½ (429): è¯·æ±‚å¤ªå¿«äº†ï¼Œæˆ–è€…æœ¬æœˆå…è´¹é¢åº¦å·²é¢†å®Œã€‚";
            case 500: return "æœåŠ¡å™¨é”™è¯¯ (500): ä¾›åº”å•†æœåŠ¡å™¨å´©æºƒäº†ã€‚";
            case 503: return "æœåŠ¡ä¸å¯ç”¨ (503): ä¾›åº”å•†æ­£åœ¨ç»´æŠ¤ä¸­ã€‚";
            case 999: return "è¿æ¥è¶…æ—¶ (10s): æœåŠ¡å™¨å“åº”å¤ªæ…¢ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæ˜¯å¦ç¨³å®šã€‚";
            default: return QString("ç½‘ç»œé”™è¯¯ (%1): è¯·æ£€æŸ¥ API åœ°å€æ˜¯å¦æœ‰æ•ˆã€‚").arg(code);
        }
    } else { // English
        switch (code) {
            case 0:   return "Connection Timeout: Please check your network or proxy.";
            case 400: return "Bad Request (400): Please check if parameters meet model requirements.";
            case 401: return "Auth Failed (401): Invalid or expired API Key/Address.";
            case 402: return "Insufficient Balance (402): Please top up your account.";
            case 403: return "Forbidden (403): Access denied or Key lacks model permissions.";
            case 429: return "Rate Limit (429): Too many requests or quota exhausted.";
            case 404: return "Not Found (404): Check your API URL.";
            case 500: return "Server Error (500): Provider server crashed.";
            case 503: return "Service Unavailable (503): Provider is under maintenance.";
            case 999: return "Connection Timeout (10s): Server response too slow.";
            default: return QString("Error (%1): Check provider status.").arg(code);
        }
    }
}

void MainWindow::onGlossaryChanged() {
    // è·å–å½“å‰ UI çŠ¶æ€
    AppConfig currentCfg = getUiConfig(); 
    
    // å¦‚æœæœåŠ¡å™¨æ­£åœ¨è¿è¡Œï¼Œç«‹å³åŒæ­¥é…ç½®åˆ° Server å®ä¾‹
    if (m_isServerRunning && server) {
        server->updateConfig(currentCfg);
        
        // æ‰“å°åé¦ˆæ—¥å¿—
        QString msg = (m_currentLang == 0) 
            ? QString("ğŸ”„ Glossary switched to: %1").arg(currentCfg.glossary_path)
            : QString("ğŸ”„ æœ¯è¯­è¡¨å·²åˆ‡æ¢è‡³: %1").arg(currentCfg.glossary_path);
        onLogMessage(msg);
    }
}
